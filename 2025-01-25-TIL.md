# WITH 문
- SQL에서 COMMON TABLE EXPRESSIONS를 정의하기 위한 구문
- SUBQUERY를 재사용 가능하고 가독성 높게 작성할 수 있도록
- 복잡한 SQL쿼리를 읽기 쉽고 관리 가능하게 구조화
- 동일한 서브쿼리를 반복적으로 재작성하지 않아도 된다
- 재귀 쿼리 작성 시 활용

```sql

WITH DepartmentSalary AS (
    SELECT DEPARTMENT_ID, ROUND(AVG(SALARY), 2) AS AVG_SALARY
    FROM EMPLOYEES
    GROUP BY DEPARTMENT_ID
    ORDER BY DEPARTMENT_ID NULLS LAST
)

SELECT *
FROM DepartmentSalary
WHERE AVG_SALARY > 5000;
```

- 다중 CTE
    - 다중 CTE는 **여러 개의 CTE를 동시에 정의**하여 하나의 쿼리에서 사용합니다.
    - 많이 사용하지는 않음
    
    ```sql
    WITH CTE1 AS (
    	SELECT ...
    	),
    	
    	CTE2 AS(
    		SELECT ...
    		FROM CTE1
    	)
    	
    WITH
    cte1 AS (
        SELECT employee_id, name, department_id
        FROM employees
        WHERE active = 1
    ),
    cte2 AS (
        SELECT department_id, AVG(salary) AS avg_salary
        FROM employees
        GROUP BY department_id
    ),
    result AS (
        SELECT c1.name, c2.avg_salary
        FROM cte1 c1
        JOIN cte2 c2 ON c1.department_id = c2.department_id
    )
    SELECT *
    FROM result;
    ```
    
- 재귀 CTE
    - 자주 사용되지 않음
    
    ```sql
    WITH NUMBERS(NUM) AS(
        SELECT 1 AS NUM
        FROM DUAL
        UNION ALL
        SELECT NUM+1 AS NUM
        FROM NUMBERS
        WHERE NUM < 10
    )
    
    SELECT B.NUM
    FROM NUMBERS BTE
    ```
    

- WITH문 사용 시 주의사항
    - CTE는 임시적으로 데이터를 메모리에 저장하여 처리(PGA 이용)
    - PGA 부족 → Temp Tablespace 공간 사용
    - CTE 결과를 도출하는 데에 복잡한 계산이 이루어져야 함
        - 데이터양이 많은 경우에도 초기 비용이 들더라도 TEMP 영역에 저장해두는것이 유리
        - 데이터양이 적고 결과 도출 비용이 크지 않는 경우 TEMP영역 저장 비용이 더 커버릴 가능성 존재(PGA로 해결이 되는지?)

- TEMP TABLESPACE 사용 확인
- 데이터 정렬 작업(RODER BY, GROUP BY, DISTINCT)에서 메모리 다 사용하면 TEMP 사용함ㄹㄹㄹ


 # 1. Nested Loop Join

- 중첩 for문과 유사한 형태
- driving 테이블의 처리에 의해 전체 일량이 결정
- join 컬럼이 driven 테이블의 index로 설정되어 있어야 유리
- oltp성 쿼리에 적합
- 자주 호출되는 column 가벼운 테이블
- hint : use_nl

- 필터 조건이 없으면 데이터의 규모가 크면서 중복 값이 있을 때 ⇒ driving 테이블로 하면 유리 ⇒ index로 하자!

- 필터 조건이 있으면 덩치가 크더라도 앞에 있으면 ㄱㅊ

# 2. Hash Join

- Join 컬럼에 인덱스가 없어 NL join이 효과적이지 못한 상황에 대한 대안
- join 컬럼에 인덱스는 있지만 driving table에서 driven table로의 액세스량이 많아 random access 부하가 심한경우
- 두 테이블 중 작은 테이블을 메모리에 생성
- 큰 테이블이 driving 테이블이 되어 join 데이터의 hash값을 메모리의 hash 값과 비교 => 동일한 레코드를 결과 목록에 추가
- Table Random Access 부하가 없음
- 수행빈도가 낮고 시간이 오래 널리는 olap성 쿼리에 적합

<aside>
💡

Index vs Hash Join

</aside>

- Index는 한 번 생성해 놓으면 계속해서 사용할 수 있는 영구적인 오브젝트인 반면 Hash Table은 단 하나의 쿼리를 위해 생성하고 Join이 끝나면 소멸한는 자료구조
    - 수행빈도 높은 OLTP성 쿼리 ⇒ Hash Join으로 처리하면 CPU와 메모리 사용률 크게 증가

# 3. 실행계획

- SQL로 요청한 데이터를 어떻게 꺼내 올 것인가에 대한 PLAN
- 성능 병목 현상을 파악하는 데 유용
- DBMS_XPLAN 패키지를 사용하여 실행 계획을 읽기 쉽게 출력 ⇒ 튜닝에 더 적합
- EXPLAIN PLAN FOR은 미래 실행계획을 예측하는 것임

## 3.1 Access 조건

- 인덱스나 테이블에 접근할 때 사용하는 조건, 검색 제한
- 데이터 액세스를 효율적으로 제한하여 불필요한 I/O를 줄임
- ex : Department_id = 10

## 3.2 Filter 조건

- 데이터를 반환한 후 주기적으로 필터링하는 조건
- 반환된 데이터 중 조건에 맞지 않은 데이터 제거
- Access 조건보다 덜 효율적
- SALARY > 5000

## SORT AGGREGATE

- 데이터를 정렬하지 않고 집계함수 사용 ⇒ GROUP BY 사용하지 않고 SUM 사용

---

```sql
ALTER SESSION SET STATISTICS_LEVEL=ALL;

SELECT * FROM EMPLOYEES WHERE ROWNUM <= 100; -- 실행계획 확인하고자 하는 쿼리

SELECT * FROM TABLE(dbms_xplan.display_cursor(NULL, NULL, 'ALLSTATS LAST'));

```
