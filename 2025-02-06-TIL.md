# 2025-02-06-TIL

# 11. **상속과 관련된 constructor의 특징**

- constructor는 상속되지 않는다.
- 프로그래머가 명시하지 않아도 constructor가 호출될 때 자동적으로 상위 class의 constructor를 호출한다.
- sub class의 객체를 생성할 경우 먼저 super class의 객체가 만들어 져야 하기 때문에 super class의 constructor가 호출
- 주의할 것은 이때 자동적으로 호출되는 상위 class의 constructor는 인자가 없는 constructor가 호출된다는 것이다.

![image.png](attachment:8dc7f086-fe54-4d33-9304-613f4c5d41a8:image.png)

# **method overriding**

- overriding은 부모로부터 물려받은 method의 내용을 하위 class에서 다시 정의하는 것.
- method overriding의 조건
- method의 이름이 같아야 한다.
- method의 return type이 같아야 한다.
- method의 parameter개수와 type이 같아야 한다.
- access modifier는 부모의 것과 같거나 더 넓어야 한다.

## IS-A Relationship

- `Sub class is a Super class`
- sub class type을 써야 하는 자리에 super class의 type을 사용해도 된다.
- Type casting ⇒ 다형성

```java
package inhabitance;

class SuperClass {
    static int staticCall(String msg) {
        System.out.println(msg);
        return 0;
    }

    int a = staticCall("1번 문장입니다.");
    static int b = staticCall("2번 문장입니다.");

    public SuperClass() {
        // super() 생략
        staticCall("3번 문장입니다.");
    }

    public SuperClass(int i) {
        this();
        staticCall("4번 문장입니다.");
    }

    public void myFunc() {
        System.out.println("5번 문장입니다.");
    }
}

```

```java
package inhabitance;

public class Exam01_InheritanceOrder extends SuperClass{
    int c = staticCall("6번 문장입니다.");
    static int d = staticCall("7번 문장입니다.");

    public Exam01_InheritanceOrder() {
        super(100);
        staticCall("8번 문장입니다.");
        super.myFunc();
    }

    @Override
    public void myFunc() {
        System.out.println("9번 문장입니다");
    }

    public static void main(String[] args) {
        System.out.println("10번 문장입니다");
        SuperClass c = new Exam01_InheritanceOrder();
        c.myFunc();
    }
}

```

---

<aside>
💡

과정

- [https://velog.io/@thdqudgns/Java의-정석-정리-초기화](https://velog.io/@thdqudgns/Java%EC%9D%98-%EC%A0%95%EC%84%9D-%EC%A0%95%EB%A6%AC-%EC%B4%88%EA%B8%B0%ED%99%94)
</aside>

- 먼저 `SuperClass` 의 정보부터 class 정보를 Method Area에 올림
    - 그리고 `static int b` 는 실제값이 할당(2번)
    - 그 다음 하위클래스의 `static int d` 실제값이 할당(7번)
- 그 후 `main()` 메소드 실행
    - 입출력 (10번)
    - `Exam01_InheritanceOrder` 의 constructor 실행
        - super(100) ⇒ this() ⇒ 초기화코드 실행 ⇒ staticCall(3번) 실행하기 전 int a(1번) 초기화
        - 그 후 staticCall(3번) 실행
        - 그 후 4번 출력하고 상위클래스 초기화 종료
        - 그리고 하위클래스 초기화 진행
            - `int c` (6번)
            - staticCall(8번)
            - super.myFunc() ⇒ (5번)
    - 그리고 obj.myFunc() ⇒ 9번

## final keyword

- class : 더 이상 상속할 수 없음
- field : 변경할 수 없음
- method : overriding할 수 없음

## abstract class

```java
package inhabitance;

public abstract class MyClass {

    int kk;

    public MyClass(int kk) {

    }

    // 메소드의 정의
    public void printInfo() {
        System.out.println("Logic 처리");
    }

    public abstract void myFunc();
}

class MySubClass extends MyClass {
    @Override
    public void myFunc() {
        
    }
}
```

## Interface

- Interface로 구현

```java
package inhabitance;

public interface MyInterface {

    // field
    public static final int k = 100;

    // methods
    // interface 안의 메소드는 모두 abstract method이다!
    public abstract void printInfo();
    public int myData(int kk);

    
}

```
