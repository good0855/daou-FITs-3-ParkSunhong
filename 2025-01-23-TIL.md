# 2025-01-23-TIL
## Index

- 인덱스 : B-Tree 구조
    - 데이터가 정렬된 상태로 유지 ⇒ 검색, 삽입, 삭제 시 효율적임
    - 리프 노드에는 식제 데이터 위치 정보 저장

- Sequential Access vs Random Access
- 

- SQL 실행 순서
    1. SYNTAX CHECK
    2. SEMANTIC CHECK = 권한 체크 등
    3. SHARED POOL CHECK = 자주 쓰는 SQL들을 해당 POOL에 올라감
    4. 
- HARD PARSING VS SOFT PARSING
    - SOFT PARSING : 기존 실행 계획을 재실행하는 것
        - SOFT PARSING : 쿼리가 완전히 문자 그대로 똑같아야 함
    - HARD PARSING : SQL 실행 순서 진행

## 인덱스 관리 팁

- 자주 사용되는 컬럼에 생성
    - WHERE, JOIN, ORDER BY, GROUP BY, SELECT에 자주 등장하는 칼럼
        - 특히 결합 인덱스에서 활용
        - 적절한 인덱스 개수 유지

## INDEX SCAN

### 1. INDEX RANGE SCAN

- 전략
    1. 인덱스 스캔 범위 줄이기
    2. 테이블 액세스 빈도 줄이기
    3. 인덱스를 구성하는 선행 컬럼을 조건절에 사용
    4. equal 조건으로 자주 쓰이는 컬럼을 선행 컬럼으로 사용

### 인덱스를 활용하지 못하게 하는 주요 원인

- 인덱스 컬럼에 함수 또는 연산 사용
    - FUNCTION BASED INDEX 활용 ⇒ 함수를 씌운 채로 INDEX
- 데이터 타입 불일치
- 와일드카드 사용 위치
- NULL값 처리 ⇒ NULL은 저장되지 않음
- OR 조건이 포함된 경우 ⇒ 실행계획 확인해봐야 안다.

### INDEX 종류

- **REVERSE KEY INDEX**
    - 인덱스에 저장되는 키 값을 반대로 뒤집어서 저장함.
    - 데이터가 순차적으로 들어올 때 특정 블록에 몰리는 걸 방지하려고 씀.
    - 주로 **INSERT 작업이 많을 때** 유용함.
    - **읽기 작업 많은 테이블에는 별로**고, **EQUAL 검색**만 가능해서 범위 검색은 안 됨.
- **FUNCTION BASED INDEX**
    - 컬럼에 특정 함수나 계산식을 적용한 결과를 기준으로 만든 인덱스임.
    - 예를 들어, `UPPER(column_name)`이나 `(column1 + column2)` 같은 계산식에 쓸 때 유용함.
    - 조건문에 함수가 포함될 때도 **성능 최적화** 가능함.
    - 다만, 함수가 **결정적(Deterministic)**이어야 하고 테이블이 지원하는 데이터 타입이어야 함.
- **CLUSTERED INDEX**
    - 데이터를 물리적으로 정렬해서 저장함. 테이블당 하나만 만들 수 있음.
    - 테이블의 기본 키에 자동으로 생성되거나 명시적으로 만들 수도 있음.
    - **읽기 성능이 진짜 좋음**, 테이블이랑 인덱스를 따로 조회할 필요가 없음.
    - **범위 검색**이나 **연속된 데이터 조회**에서 효과적임.
    - 근데 **INSERT/UPDATE/DELETE 작업**은 느려질 수도 있음.
