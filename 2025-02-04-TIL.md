## 2025-02-04 TIL

> jdk version : oracle jdk 1.8
Tools : IntelliJ
> 

- JVM : 플랫폼 종속
- 컴파일 과정
    - `.java` → `.class` → machine code
- 

- 절차적 프로그래밍
    - 기능으로 프로그램 세분화 ⇒ 단위기능을 함수로 만듦
    - 장점 : 요구사항 분석이 쉬움(설계와 구현이 거의 동일) ⇒ 구현이 빠름
    - 단점 : 확장을 고려한 유지보수가 어려움
- 객체지향적 프로그래밍
    - 현실 세계를 프로그램으로 모델링
    - 설계 단계가 길어짐

## JVM vs JRE vs JDK

- JVM
    - 자바 가상 머신
    - 바이트코드를 읽어서 실행하는 실행 주체
- JRE
    - 자바 실행 환경
    - JVM + 여러 클래스 라이브러리 합쳐놓은 것
- JDK
    - JRE + 자바개발도구(javac, javadoc, java, etc)

## Java의 객체지향

- 현실 세계에서 구현해야 하는 문제 ⇒ 프로그래밍적으로 표현(모델링)
- 해결해야 하는 문제를 구성하고 있는 구성요소 파악(ex. 은행 서비스 ⇒ 어떤 것을 구현해야 하는가?)
    - 이때 눈에 보이든 보이지 않든 상관 x
- 구성 요소 파악 후 프로그램으로 표현!
- 꼭 필요한 기능만 단순화(추상화)
- 추상화를 거쳐서 나온 정보
    - 상태
    - 행위로 표현
- 객체 모델링 : 클래스 활용
- 클래스
    1. 인스턴스 파생
    2. 추상 데이터 타입

- 클래스 : 단위기능
- 패키지 : 클래스 효과적으로 관리하기 위해 동일한 기능 모아놓음
    
    <aside>
    💡
    
    모든 클래스는 반드시 하나의 패키지에 포함되어야하며, 소스파일에 자신이 속할 패키지를 지정하지 않는 모든 클래스는 자동적으로 자바에서 기본적으로 제공하는 '이름없는 패키지(unnamed package 또는 default package)'에 속하게 된다.
    
    </aside>
    

---

## Data Type

- Java는 변수명(식별자) 길이의 제한이 없다
- 예약어로는 변수를 만들 수 없다.
- 숫자로 시작하는 변수를 만들 수 없다.
- 특수문자는 _와$ 허용
- 클래스 이름은 Pascal Case (MyFriend)
- 일반 변수 이름은 camel case(myFriend)

### 종류

1. Primitive Data Type
    
    <aside>
    💡
    
    해당 타입으로 선언된 변수 안에 직접 데이터가 저장
    
    - primitive type ⇒ 스택에 저장된다(x)
    </aside>
    
    - boolean
    - byte
    - short
    - char
    - int
    - long
    - float
    - double
2. Reference Data Type (Class)
    - 클래스로 선언된 변수를 지칭
    - 해당 타입으로 선언된 변수 안에는 메모리 주소(실제로는 hash값)가 저장

## JVM 메모리 load

https://velog.io/@impala/JAVA-JVM-Runtime-Data-Area

- Method Area
    - VM이 시작될 때 생성되는 공간으로 바이트 코드(.class)를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간이다.
    - JVM이 동작하고 클래스가 로드될 때 적재돼서 프로그램이 종료될 때까지 저장된다.

### 실행 과정

![image.png](attachment:fb90eb33-1376-41fb-8755-b0693b72c5e6:image.png)

```java
package mypackage.com;

public class Customer {

    // fields
    int age;

    // 변수

    // 생성자(constructor) - 인스턴스 생성용

    // 메소드
    public void myprint() {
        System.out.println("안녕하세요");
    }

    public static void main(String[] args) {
        int age = 100; // 지역변수!
        
        Customer c = new Customer();
    }
}
```

1. class의 정보를 **method area**에 로드
    1. `int age`, `myprint()` , `main()` 등 정보
    - main은 `static` 이므로 method area
2. main 메소드 호출되면 **stack area**에 할당
    - 이때, main에서 호출한 지역변수 또한 할당
    - `int age = 100` 이 선언 및 할당
3. main 메소드 다 끝나면 stack area에서 해제
4. `Customer c` 라는 인스턴스 정보가 **Heap area**에 할당
    - `age` 라는 변수의 공간이 여기서 할당
    - `myprint()` 함수 또한 할당 ⇒ 하지만 함수에 대한 코드 정보는 이미 method area에 할당해서 여기서는 단순히 link값
5. `Customer c` 라는 인스턴스 변수는 **stack area**에 할당
    - c라는 reference 변수는 heap area에 있는 인스턴스 정보 참조
6. 다 실행한 후 
    - **stack area 다 비워짐**
    - 더 이상 stack area와 연결된 것이 없으므로 **heap area**의 정보는 **GC**(Garbage Collector)가 sweep
    - **method area** 다 비우고 프로그램 종료

## 상수

- `final` 이라는 keyword를 통해 상수 정의
- 관용적으로 대문자 + snake case 사용 (EX. `MY_AGE`)
- final
    
    ![image.png](attachment:a993def4-d282-45e0-9dd4-d9f3b4452844:image.png)
    

## 형 변환(Type Casting)

- 묵시적 형변환
    - 자동적 형 변환
    - 범위 작은 형과 큰 범위 연산 ⇒ 일반적으로 큰 범위로
- 명시적 형변환
    - `(int) a`

---

# 객체지향

## `this`

- 객체를 가리키는 레퍼런스

## `static`

- Java에서는 전역변수라는 개념이 존재하지 않는다.

```java
package mypackage.com;

public class InstanceTest {

    // static을 사용함으로써 instance를 만들지 않고도 int a라는 공간이 존재 => method area에 생성
    static int a = staticCall("1번"); // static variable(class variable)
    int b = staticCall("2번"); // instance variable

    static public int staticCall(String msg) {
        System.out.println(msg);
        return 100;
    }

    // constructor
    // 생성자는 기본 생성자라도 무조건 명시적으로 작성하는 게 좋다.
    // 생성자 = 만들어진 instance를 초기화하는 역할
    public InstanceTest() {
        this.b = staticCall("3번");

    }

    // entry point
    public static void main(String[] args) {
        System.out.println("4번");
        int c = staticCall("5번"); // instance가 없어도 실행

        InstanceTest d = new InstanceTest();
    }

}
```

## 실행 순서

<aside>
💡

static 메서드, 생성자 ⇒ stack 영역에 호출

</aside>

1. `InstanceTest` 라는 클래스의 정보가 method area에 들어감
    - 이때, static 변수인 a의 공간 또한 method area에서 할당(a = 100).
    - static method 인 `staticCall` 또한 별도의 instance를 생성하지 않고도 사용 가능함(만약 staticCall이 static method가 아니라면 에러)
    - 따라서 **`“1번”`  이라는 문구가 출력**
    - b는 별도의 공간이 만들어지지 않음(static이 아니어서 instance가 생성된 후에 heap에 공간 할당)
    - 이외 생성자, main메소드 또한 정보 올라감
2. main 메서드 실행
    - `“4번”`이라는 문구 출력
    - `staticCall` 실행되면서 `“5번”` 이라는 문구 출력

1. 그리고 d라는 InstanceTest라는 변수를 위해 `InstanceTest()` 호출
- `new` 키워드 : 인스턴스 만듦(공간 초기화하면서)
- 그 과정에서 InstanceTest의 field `b`초기화 ⇒ `“2번”` 출력
- 그리고 생성자 초기화 ⇒ `“3번”` 출력
    - 생성자 = 초기화(heap영역에 공간 할당) 역할

## Overloading

- 같은 이름, 같은 형태로 실행
- **메소드 시그니처** ⇒ 메소드명, 매개변수의 개수 및 자료형을 의미
- **이름은 같지만,** 메소드 시그니처가 다르면 다른 메소드처럼 사용 ⇒ 메소드 오버로딩
- 생성자에도 적용
    
    ```java
    package mypackage.com;
    
    public class InstanceTest {
    
        int a;
        
        public InstanceTest() {
    
        }
        
        public InstanceTest(int a) {
            this.a = a;
        }
    
        // entry point
        public static void main(String[] args) {
        }
    
    }
    ```
