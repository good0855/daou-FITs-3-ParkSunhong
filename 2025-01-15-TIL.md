# 정렬, 쿼리순서

## ORDER BY

- 기본적으로 오름차순 정렬
- 하나 이상 칼럼을 기준으로 정렬 가능

- `NULL`
    - 오라클에서는 NULL값은 최대값으로 간주
    - `NULLS FIRST` , `NULLS LAST` 로 설정 가능

```sql
SELECT NAME, SALARY
FROM EMPLOYEES
ORDER BY SALARY ASC NULLS FIRST
```

## SQL 쿼리 순서

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/b367ca3a-9b32-4e21-99ce-52536c491502/8081cf8a-8986-41be-8452-8cec4f4b61f6/image.png)

# 페이징 쿼리

## ROWNUM

- 오라클에서 결과 집합의 각 행에 부여되는 번호, pseudo column

```sql
SELECT ROWNUM FROM CUSTOMERS;
```

- ROWNUM이 매겨지는 것은 랜덤이다!
- `ROW_NUMBER()` : 오라클의 윈도우 함수로, 정렬 기준에 따라 고유 번호 부여

- Oracle 12c부터는 OFFSET과 FETCH NEXT를 활용해서 페이지를 더 간단하고 효율적으로 구현

## DISTINCT

- 특정 칼럼의 고유한 값만 조회 가능
- NULL제거 및 중복 제거

```sql
SELECT DISTINCT ACCOUNT_TYPE FROM ACCOUNTS;

-- 계좌 테이블에서 고객 ID, 계좌 타입 셋을 중복 없이 조회
SELECT DISTINCT CUSTOMER_ID, ACCOUNT_TYPE FROM ACCOUNTS;
```

## GROUP BY

- 데이터베이스에서 데이터를 특정 기준으로 묶는 작업
- `WHERE` 절과 함께 사용 가능
- `COUNT` 내에서 쓸 수 있는 것
    - `DISTINCT`
    - `*` + NULL값 count
    - COLUMN 명 = NULL값 count X
    - `1` : `*` 와 똑같음

```sql
SELECT DEPARTMENT_ID, AVG(SALARY) AS AVG_SALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID;
```

- `HAVING` : GROUP BY 조건 이후 필터링

```sql
SELECT DEPARTMENT_ID, AVG(SALARY) AS AVG_SALARY
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) >= 6000;
```

# 함수
## 단일 행 함수

> 한 행에 대해 하나의 결과를 반환
> 

## 집계함수

> 여러 행을 그룹으로 묶어 하나의 결과 반환
> 

## 날짜함수

> 날짜 및 시간 데이터
> 
- `SYSDATE()` , `CURRENT_DATE()` : 날짜 함수
    - `SYSDATE()` : 가장 빈번하게 사용
    - SYSDATE 시간 설정
    - 도구 > 환경설정 > 데이터베이스 > NLS
    
    `RR/MM/DD HH24:MI:SSXFF` 로 설정
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/b367ca3a-9b32-4e21-99ce-52536c491502/83a1ce48-a033-4c60-a4c0-7b2dfc1c4d80/image.png)
    
- `ADD_MONTHS()`, `MONTH_BETWEEN()` : 날짜 계산
    
    ```sql
    SELECT ADD_MONTHS(SYSDATE, 2) AS TWO_MONTHS_LATER,
    MONTHS_BETWEEN(SYSDATE, TO_DATE('2024-01-01', 'YYYY-MM-DD')) AS MONTH_DIFF
    FROM DUAL;
    ```
    
- `NEXT_DAY()`, `LAST_DAY()` : 지정된 요일의 다음 날짜, 해당 월의 마지막 날 반환
    
    ```sql
    SELECT NEXT_DAY(SYSDATE, '일요일') AS NEXT_SUNDAY,
    LAST_DAY(SYSDATE) AS END_OF_MONTH
    FROM DUAL;
    ```
    
- `EXTRACT()`, `TRUNC()` : 날짜에서 특정 요소 추출과 날짜를 특정 단위로 자름
    
    ```sql
    SELECT EXTRACT(YEAR FROM SYSDATE) AS CURRENT_YEAR,
    TRUNC(SYSDATE, 'MM') AS START_OF_MONTH
    FROM DUAL;
    ```
    
- `TO_CHAR()` , `TO_DATE()` : 데이터 형식 변환
    
    ```sql
    SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') AS DATE_STRING,
    TO_DATE('2024-12-01', 'YYYY-MM-DD') AS DATE_VALUE,
    TO_NUMBER('1234') AS NUMERIC_VALUE
    FROM DUAL;
    ```
    
- `NVL()` : NULL 값 대체
    
    ```sql
    SELECT NVL(NULL, 'Default') AS RESULT
    FROM DUAL;
    ```
    

- `COALESCE()` : NULL이 아닌 첫 번째 값 반환
    
    ```sql
    SELECT
    COALESCE(NULL, NULL, 'First Non-NULL') AS RESULT
    FROM DUAL;
    ```
    

- `NULLIF()` : 두 값이 같으면 NULL 반환

```sql
SELECT NULLIF(1, 1) AS RESULT
FROM DUAL;
```

## 숫자함수

> 숫자를 다루기 위한 함수
> 
- `ROUND()`, `TRUNC()` : 숫자 반올림과 자르기

```sql
SELECT ROUND(123.456, 2) AS ROUNDED,
TRUNC(123.456, 2) AS TRUNCATED
FROM DUAL;
```

- `CEIL()`, `FLOOR()` : 숫자를 올림과 내림(두 번째 인수가 없다)

```sql
SELECT CEIL(123.456) AS CEILED,
FLOOR(123.456) AS FLOORED
FROM DUAL;
```

- `ABS()`, `MOD()` : 절댓값과 나머지 계산

```sql
SELECT ABS(-123) AS ABSOLUTE,
MOD(10, 3) AS REMAINDER
FROM DUAL;
```

## 문자함수

> 문자열을 다루기 위한 함수
> 
- `UPPER` , `LOWER` : 대소문자 변환

```sql
SELECT UPPER('hello') AS UPPERCASE,
LOWER('WORLD') AS LOWERCASE
FROM DUAL;
```

- `SUBSTR()`, `LENGTH()`
    - `SUBSTR()`
        - (시작점, 길이) ⇒ 시작점은 1부터, 음수면 뒤에서부터

```sql
SELECT LENGTH('SQL Function') AS LENGTH,
SUBSTR('SQL FUNCTION', 5, 8) AS SUBSTRING
FROM DUAL;
```

- `INSTR()`, `TRIM()`
    - `INSTR()` : 특정 문자열의 처음 위치 출력
    - `TRIM()` : 공백 지워주기, `LTRIM()`, `RTRIM()`
    
    ```sql
    SELECT INSTR('ORACLE SQL', 'SQL') AS POSITION,
    TRIM(' ORACLE SQL ') AS TRIMMED_STRING
    FROM DUAL;
    ```
    

- `LPAD()`, `RPAD()` : 문자열 채움

```sql
SELECT LPAD('SQL', 10, '*') AS LEFT_PADDED,
RPAD('SQL', 10, '*') AS RIGHT_PADDED
FROM DUAL;
```

- `REPLACE()`, `CONCAT()` : 문자열 대체와 두 문자열 연결
    - `CONCAT()` 은 `||` 와 동일
    
    ```sql
    SELECT REPLACE('Hello SQL', 'SQL', 'Oracle') AS REPLACED_STRING,
           CONCAT('Hello', 'World') AS CONCATENATED_STRING,
           'HELLO ' || 'WORLD' AS TEXT
    FROM DUAL;
    ```

# CASE WHEN / DECODE
## CASE WHEN

- `CASE` 뒤에 column이 있으면 = 단순 EQUAL연산만 가능
- 조건 처리에 유연함
- 여러 조건 및 복잡한 로직 처리 가능

```sql
SELECT EMPLOYEE_ID,
	CASE
		WHEN SALARY > 10000 THEN 'HIGH'
		WHEN SALARY BETWEEN 5000 AND 10000 THEN 'MEDIUM'
		ELSE 'LOW'
	END AS SALARY_LEVEL
FROM EMPLOYEES;
```

## DECODE

- 특정 값에 따라 다른 값을 반환하는 함수
- `SELECT` 문에서 주로 사용
- `CASE WHEN` 보다 간단한 조건 처리에 적합
- `DECODE(표현식, 조건1, 결과1, 조건2, 결과2, ... , 기본값)

```sql
SELECT EMPLOYEE_ID,
	DECODE(JOB_ID,
		'ADMIN', '관리자',
		'DEV' , '개발자', 
		'HR', '인사담당자',
		'기타') AS DEPARTMENT_NAME
		FROM EMPLOYEES;
```
# JOIN
## 1. Inner Join

## 2. Outer Join

- 일치하지 않는 경우 NULL 반환

### Left Outer Join

### Right Outer Join

- Right 테이블의 모든 행과 일치하는 LEFT 테이블의 데이터를 반환
- 일치하지 않는 경우 NULL 반환
- 거의 안쓰임

### Full Outer Join

- Left Outer Join + Right Outer Join

## 3. Self Join

- 같은 테이블을 두 번 사용하여 JOIN 수행
- 계층 쿼리 용도로 쓰인다.

```sql
SELECT E1.NAME AS EMPLOYEE, E2.NAME AS MANAGER
FROM EMPLOYEES E1
JOIN EMPLOYEES E2
ON E1.MANAGER_ID = E2.EMPLOYEE_ID;
```

## 4. Cross Join

- 두 테이블 간의 모든 행의 조합 반환

## 5. Natural Join

- 동일한 이름의 컬럼을 기준으로 JOIN
- 조건을 명시하지 않아도 자동으로 연결

## JOIN 시 유의사항

1. JOIN 조건 누락
    - JOIN 조건 없으면 CROSS JOIN과 동일한 결과
2. NULL 처리
    - OUTER JOIN시 NULL값을 처리하는 로직 필요
3. 성능
    - 큰 테이블 간 JOIN은 성능 저하 가능, 적절한 인덱스 설정 필요

---

## 내부적 JOIN

1. nested loop join(NL join)
2. hash join
3. sort merge join
