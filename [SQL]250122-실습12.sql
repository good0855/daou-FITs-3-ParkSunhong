-- 실습 11
-- 1. 쇼핑 카테고리 데이터의 순방향 계층 구조에서 동일한 부모를 가진 카테고리들에 대해 이름순으로 정렬하세요.
SELECT CATEGORY_ID, PARENT_CATEGORY_ID, CATEGORY_NAME, LEVEL
FROM SHOPPING_CATEGORIES
START WITH PARENT_CATEGORY_ID IS NULL
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID
ORDER SIBLINGS BY CATEGORY_NAME;



-- 2. 이름에 'Phones'가 포함된 카테고리와 해당 계층 구조를 순방향으로 출력하세요.
SELECT CATEGORY_ID, PARENT_CATEGORY_ID, CATEGORY_NAME, SYS_CONNECT_BY_PATH(CATEGORY_NAME, '->') AS PATH
FROM SHOPPING_CATEGORIES
START WITH CATEGORY_NAME LIKE '%Phones%'
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID;


-- 3. 쇼핑 카테고리 데이터의 순방향 계층 구조에서 depth가 가장 깊은 level 값을 구하세요.
SELECT MAX(LEVEL)
FROM SHOPPING_CATEGORIES
START WITH PARENT_CATEGORY_ID IS NULL
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID;




SELECT JOB_ID, COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY JOB_ID;

SELECT JOB_ID, COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY GROUPING SETS(JOB_ID)
ORDER BY JOB_ID;


SELECT JOB_ID, DEPARTMENT_ID, COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY GROUPING SETS(JOB_ID, DEPARTMENT_ID, ())
ORDER BY JOB_ID, DEPARTMENT_ID;

-- 아래 코드와 동일
SELECT JOB_ID, NULL AS DEPARTMENT_ID, COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY JOB_ID
UNION ALL
SELECT NULL AS JOB_ID, DEPARTMENT_ID, COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID
ORDER BY JOB_ID, DEPARTMENT_ID;


-- ROLLUP 씌우기
SELECT JOB_ID, DEPARTMENT_ID, COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY GROUPING SETS(JOB_ID, DEPARTMENT_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;


SELECT JOB_ID, DEPARTMENT_ID, COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY GROUPING SETS(JOB_ID, ROLLUP(DEPARTMENT_ID))
ORDER BY JOB_ID, DEPARTMENT_ID;

-- ROLLUP 씌우기
SELECT JOB_ID, DEPARTMENT_ID, COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY ROLLUP((JOB_ID, DEPARTMENT_ID))
ORDER BY JOB_ID, DEPARTMENT_ID;

SELECT JOB_ID, COUNT(*) AS CNT, GROUPING(JOB_ID)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY ROLLUP(JOB_ID)
ORDER BY JOB_ID;

SELECT JOB_ID, DEPARTMENT_ID, COUNT(*) AS CNT, GROUPING(JOB_ID), GROUPING(DEPARTMENT_ID)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY ROLLUP(JOB_ID, DEPARTMENT_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;

SELECT 
    CASE
        WHEN GROUPING(JOB_ID) = 0 THEN JOB_ID
        WHEN GROUPING(JOB_ID) = 1 THEN '총합'
    END JOB_ID,
    COUNT(*) AS CNT,
    GROUPING(JOB_ID)
    
FROM EMPLOYEES
GROUP BY ROLLUP(JOB_ID)
ORDER BY JOB_ID;

-- SQL 작성 12
-- 1. 사원 테이블에서 부서별로 급여의 합계를 계산하고 전체 합계를 함께 출력하시오(단 부서데이터가 NULL인 사원은 제외)
SELECT 
    NVL(TO_CHAR(DEPARTMENT_ID), '총합') AS DEPARTMENT_ID,
    SUM(SALARY) AS SUM_SALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY ROLLUP(DEPARTMENT_ID)
ORDER BY DEPARTMENT_ID;

-- 2. 같은 날짜에 입사한 사원이 2명 이상인 날짜와 입사한 사원수, 마지막 행은 총 직원수를 함께 출력하시오.


SELECT 
    NVL(TO_CHAR(HIRE_DATE), '총합') AS HIRE_DATE,
    COUNT(EMPLOYEE_ID) AS EMPLOYEMENT_CNT
FROM EMPLOYEES
GROUP BY ROLLUP(HIRE_DATE)
HAVING COUNT(EMPLOYEE_ID) >= 2
ORDER BY HIRE_DATE ASC;


-- 3. 각 지점별 대출 금액 합계와 모든 지점의 총합계를 출력하시오.
-- 출력 컬럼은 지점명, 대출금액 합계이며, 
-- 지점 총합계는 'All Branch` 로 출력하고 지점명으로 정렬하되 총합계는 맨 아랫줄에 나타내시오

SELECT 
    NVL(B.NAME, 'ALL Branch') as BRANCH_NAME,
    S.SUM_AMOUNT
FROM BRANCHES B
RIGHT JOIN (

    SELECT 
        BRANCH_ID,
        SUM(AMOUNT) SUM_AMOUNT 
    FROM LOANS
    WHERE BRANCH_ID IS NOT NULL
    GROUP BY ROLLUP(BRANCH_ID)
    
    ) S
ON B.BRANCH_ID = S.BRANCH_ID
ORDER BY B.NAME;
