- Interface끼리도 extends를 사용해서 확장 가능

## 설정

- Oracle 21
- JDK 17 version 기준

### 1. 라이브러리 적용

- sqldeveloper 폴더 내 jdbc\lib 내 `ojdbc11.jar`
    - oracle과 java 연결할 수 있는 일종 아카이브 라이브러리

![image.png](attachment:3cd4dcc1-05cc-4aeb-94db-fe9950d00dfa:image.png)

- C\Program Files\Java 폴더에 이 파일을 복사한다

![image.png](attachment:f5d2af36-7f4a-41b5-924d-398fd4d6c7fb:image.png)

- IntelliJ에서 project 구조에서 라이브러리 추가
    - 라이브러리 ⇒ + ⇒ Java 클릭
    - 아까 한 ojdbc 클릭

![image.png](attachment:8e204afc-5d29-46cd-9094-d81739fa4fb1:image.png)

![image.png](attachment:fdd00f1b-1277-4c9f-b13c-a55cdbfd2d42:image.png)

## 2. JDBC 과정

### 1. (JDBC) Driver Loading

- 프로그램에서 딱 한번만 수행

### 2. Database 연결

- 만약 연결이 성공하면 연결 성공의 증표로 객체가 생성!
- 객체의 클래스는 java.sql.Connection 클래스
- 연결을 하려면 3가지 정보가 필요해요!
    - 어떤 데이터베이스에 대한 정보가 필요하다.(문자열) => JDBC URL
    - - ID / PW 필요

### 3. SQL을 작성해요

- Statement를 생성

### 4. Query 실행!

- executeUpdate() : SQL 구문이 insert, update, delete계열일 때 사용
- executeQuery() : SQL구문이 select일 때 사용

### 5. 결과처리

- executeUpdate() : return값 : SQL에 의해서 영향을 받은 행의 수(int)
- executeQuery() : ResultSet이 결과로 나옴

## 6. 리소스 해제

- 지금 사용한 자원은 Connection, PreparedStatement, ResultSet
- 사용자가 수동으로 자원 해제해야 함 -> `close()` 호출
- 자원 해제는 생성 순서의 반대로진행!

## 3. 실습

```java
package first;

import java.sql.*;

public class FirstConnect {
    // 1. (JDBC) Driver Loading
    //      프로그램에서 딱 한번만 수행
    // 2. Database 연결
    //      만약 연결이 성공하면 연결 성공의 증표로 객체가 생성!
    //      객체의 클래스는 java.sql.Connection 클래스
    //      연결을 하려면 3가지 정보가 필요해요!
    //      - 어떤 데이터베이스에 대한 정보가 필요하다.(문자열) => JDBC URL
    //      - ID / PW 필요
    // 3. SQL을 작성해요 => Statement를 생성
    // 4. Query 실행!
    //      - executeUpdate() : SQL 구문이 insert, update, delete계열일 때 사용
    //      - executeQuery() : SQL구문이 select일 때 사용
    // 5. 결과처리
    //      - executeUpdate() : return값 : SQL에 의해서 영향을 받은 행의 수(int)
    //      - executeQuery() : ResultSet이 결과로 나옴
    // 6. 리소스 해제
    //      - 지금 사용한 자원은
    //      - Connection, PreparedStatement, ResultSet
    //      - 사용자가 수동으로 자원 해제해야 함 -> close() 호출
    //      - 자원 해제는 생성 순서의 바낻로 진행!
    public static void main(String[] args) {
        try {

            // Step 1. Driver loading
            Class.forName("oracle.jdbc.driver.OracleDriver"); // class가 존재하는지 확인!

            // Step 2. Database 연결
            System.out.println("Driver loaded");
            Connection con = null;
            // thin 방식 : TLS 네트워크 => 느리지만 범용적인
            // oci 방식 : driver을 통해서 => 라이브러리를 통해서 접속해서 hardware dependent => 빠름
            String JDBC_URL = "jdbc:oracle:thin:@localhost:1521:xe"; // jdbc:[db이름 종류]:[연결 방식]:[endpoint]:[db이름]
            String ID = "C##DEV";
            String PW = "1384";
            con = DriverManager.getConnection(JDBC_URL, ID, PW);
            System.out.println("Connection established");

            // Step 3. sql query 작성
            String sql = "SELECT btitle FROM book WHERE bisbn='89-7914-063-0'";
            // SQL문장을 얹어서 보낼 Statement 객체를 생성
            // 1. 일반 statement => 단순, 기능상으로 약간 부족, 잘 안씀
            // 2. PreparedStatement => 보편적으로 사용, 편의성, 효율 높음, 보안성(SQL Injection)
            // 3. CallableStatement => 사용자 내장함수 가지고 있음(stored procedure) => Java application에서 호출 가능

            // Statement stmt = con.createStatement();

            // Step 4. SQL 실행
            PreparedStatement pstmt = con.prepareStatement(sql);
            ResultSet rs = pstmt.executeQuery();

            // Step 5. 결과 출력
            while (rs.next()) {
                System.out.println(rs.getString("btitle"));
            }

            // 6. 자원 해제
            rs.close();
            pstmt.close();
            con.close();

        } catch (ClassNotFoundException e) {
            System.out.println("Driver Not Found");
        } catch (SQLException e1) {
            System.out.println("SQL Exception");
        }
    }
}

```

```java
package first;

import java.sql.*;
import java.util.Scanner;

import static java.lang.Class.forName;

// 책 제목에 대한 키워드 입력받아서 그 키워드를 가지고 있는 책 출력
public class SecondConnect {

    public static void main(String[] args) {

        try {
            Class.forName("oracle.jdbc.driver.OracleDriver");

            String JDBC_URL = "jdbc:oracle:thin:@localhost:1521:xe";
            String ID = "C##DEV";
            String PW = "1384";

            // driver loading and conn
            Connection con = DriverManager.getConnection(JDBC_URL, ID, PW);
            System.out.println("Connection Established");

            // data 입력
            Scanner sc = new Scanner(System.in);
            System.out.print("keyword를 입력하세요 : ");
            String keyword = sc.nextLine();

            // sql query
            String sql = "SELECT btitle, bauthor, bprice" +
                        " FROM book" +
                        " WHERE btitle LIKE ?";
            PreparedStatement pstmt = con.prepareStatement(sql);
            pstmt.setString(1, "%" + keyword + "%");
            ResultSet rs = pstmt.executeQuery();

            while(rs.next()) {
                System.out.printf(
                        "%s | %s | %s\n",
                        rs.getString("btitle"),
                        rs.getString("bauthor"),
                        rs.getInt("bprice"));
            }

            rs.close();
            pstmt.close();
            con.close();

        } catch (ClassNotFoundException e) {
            System.out.println("ClassNotFoundException: " + e.getMessage());
        } catch (SQLException e1) {
            System.out.println("SQLException: " + e1.getMessage());
        }

    }
}
```

## 트랜잭션 설정 방법

- JDBC를 활용해서 설정한다면 connection에 설정 가능하다!
- 실습용 ddl
    - 
    
    ```java
    create table memberTb1 (
    member_id varchar2(50),
    member_nname varchar2(100));
    ```
    

- 기본적으로 auto commit모드로 connection이 생성 ⇒ sql 구문 하나가 transaction 자체(단일 sql = 단일 transaction)
- 명시적으로 con.commit() 혹은 con.rollback()이 호출되면 transaction이 종료추가적으로 만약 해당 구문이 나오지 않고 connection이 정상종료되면 con.commit()으로 간주

```java
package first;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;

public class TransactionTest {
    public static void main(String[] args) {
        // 기본적인 JDBC 코드 생성
        Connection conn = null;

        try {
            // driver loading
            Class.forName("oracle.jdbc.driver.OracleDriver");

            String JDBC_URL = "jdbc:oracle:thin:@localhost:1521:xe";
            String ID = "C##DEV";
            String PW = "1384";
            Connection con = DriverManager.getConnection(JDBC_URL, ID, PW);
            // 기본적으로 auto commit 모드로 connection이 수행된다.
            con.setAutoCommit(false); // 자동 모드 종료
            // 명시적으로 con.commit() 혹은 con.rollback()이 호출되면 transaction이 종료
            // 추가적으로 만약 해당 구문이 나오지 않고 connection이 정상종료되면 con.commit()으로 간주

            String sql = "Insert into memberTbl values(?,?)";
            PreparedStatement pstmt = con.prepareStatement(sql);
            pstmt.setString(1, "2");
            pstmt.setString(2, "신사임당");

            int result = pstmt.executeUpdate(); // return값은 영향받은 row의 수

            if(result == 1) {
                System.out.println("잘 처리되었음");
            } else {
                System.out.println("잘 처리되지 않았음");
            }

            // 지금까지 했던 transaction 반영 후 종료
            con.commit();

            // 지금까지 했던 작업 모두 rollback
            // con.rollback();

            pstmt.close();
            con.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}

```
