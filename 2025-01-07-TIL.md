# TIL : 알고리즘 및 자료구조

## 학습 날짜 : 2024년 01월 07일

## 어떤 문제가 있었는지
- 알고리즘 복습 진행

## 그 문제를 해결하기 위해 내가 시도해본 것들

## 어떻게 그 문제를 해결했는지

## 오늘 내가 새롭게 배운 것
### 1. 시간복잡도 및 정렬 알고리즘 시간복잡도 비교
트리 :  배열, 연결 리스트 등 자료구조를 활용해 구현 가능 TIL : 알고리즘 및 자료구조

## 학습 날짜 : 2024년 01월 07일

## 어떤 문제가 있었는지
- 알고리즘 복습 진행

## 그 문제를 해결하기 위해 내가 시도해본 것들

## 어떻게 그 문제를 해결했는지

## 오늘 내가 새롭게 배운 것
### 1. 시간복잡도 및 정렬 알고리즘 시간복잡도 비교
트리 :  배열, 연결 리스트 등 자료구조를 활용해 구현 가능 
배열은 heap을 활용

### 2. 탐색
1. 선형 탐색
2. 이진 탐색

### 3. 정렬
1. 선택 정렬
- 정렬되지 않은 데이터 중에서 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환해나가는 방식(작은 것을 **선택** 후 앞의 데이터와 교환)
```python

def selection_sort(data):
    # pivot을 뒤로 가며
    # 해당 pivot과 끝점 내에 있는 것들 중에서 가장 작은 값을 pivot으로 보냄

    for pivot in range(0, len(data)):
        tmp = data[pivot]
        tmp_idx = pivot
        for idx in range(pivot+1, len(data)):
            # 가장 작은 값 찾기
            if data[idx] < tmp:
                tmp = data[idx]
                tmp_idx = idx
        
        # swap
        data[pivot], data[tmp_idx] = data[tmp_idx], data[pivot]

    return data

```

2. 삽입 정렬
- 아직 정렬되지 않은 임의의 데이터를, 이미 정렬된 부분의 적절한 위치에 **삽입**해가며 정렬하는 방식.
- 앞에서부터 순서대로 찾아가며, 정렬된 데이터 안에 삽입
```python
# 삽입 정렬
def insertion_sort(data):
    # 앞에서부터 하나씩 찾아가면서 이미 정렬된 section의 원소와 비교하여 삽입

    for pivot in range(1, len(data)):
        pivot_data = data[pivot]

        for idx in range(0, pivot):
            if data[idx] > pivot_data:
                data[idx], data[pivot] = data[pivot], data[idx]
    
    return data
```

3. 버블 정렬
- 서로 이웃한 데이터들을 비교해 가장 큰 데이터를 맨 뒤로 보내며 정렬하는 방식

```python
# 버블 정렬
def bubble_sort(data):
    # pivot과 pivot+1부터 끝까지 비교하여 큰 값을 뒤로 swap
    for pivot in range(1, len(data)):
        for idx in range(0, pivot):
            if data[pivot] < data[idx]:
                data[pivot], data[idx] = data[idx], data[pivot]
    return data
```

4. 퀵 정렬
- 기준키를 중심으로 작거나 같은 값을 지닌 데이터는 앞으로, 큰 값을 가진 데이터는 뒤로 가게 함
```python
# 퀵 정렬
def quick(ds):
    # 1개일 때는 무시
    if len(ds) < 2:
        return ds
    else:
        key = ds[0] # 맨 앞의 것
        left = [data for data in ds[1:] if data <= key]
        right = [data for data in ds[1:] if data > key]

        return quick(left) + [key] + quick(right)
```

5. 병합 정렬
- divide and conquer을 활용해 구간을 두 부분으로 나누어, 각 부분의 원소가 1로 남을 때까지 나누고, 이제 정렬한다. 
```python
def merge_sort(arr):
    # 배열의 길이가 1 이하일 경우 이미 정렬되어 있으므로 그대로 반환
    if len(arr) <= 1:
        return arr
    
    # 배열을 두 부분으로 분할
    mid = len(arr) // 2
    left_half = merge_sort(arr[:mid])  # 왼쪽 부분
    right_half = merge_sort(arr[mid:])  # 오른쪽 부분

    # 두 부분을 병합하여 정렬된 배열을 만듦
    return merge(left_half, right_half)

def merge(left, right):
    result = []
    i = j = 0

    # 두 배열을 비교하여 작은 값부터 차례대로 result에 넣음
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # 한 배열이 다 처리되면 나머지 배열의 원소를 그대로 result에 추가
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result
```
