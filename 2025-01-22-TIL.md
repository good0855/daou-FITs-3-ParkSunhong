## 2025-01-22-TIL

### 오늘 추가적으로 배운 것

- 처음에 다음과 같이 하니 정렬이 `Total`, `=====` 등 문자열을 고려하여 정렬이 되었음
```sql

SELECT

    NVL(TO_CHAR(BRANCH_ID), 'Total') as BRANCH_ID,
    NVL(STATUS, '==========') AS STATUS,
    SUM(AMOUNT) AS SUM_AMOUNT
FROM LOANS
GROUP BY ROLLUP(BRANCH_ID, STATUS)
ORDER BY BRANCH_ID, STATUS;
```


- 원래는 이렇게 불편하게 했었음
```sql

SELECT
    NVL(TO_CHAR(BRANCH_ID), 'Total') AS BRANCH_ID,
    NVL(STATUS, '==========') AS STATUS,
    SUM_AMOUNT
FROM (    
    SELECT
        BRANCH_ID,
        STATUS,
        SUM(AMOUNT) AS SUM_AMOUNT
    FROM LOANS
    GROUP BY ROLLUP(BRANCH_ID, STATUS)
    ORDER BY BRANCH_ID, STATUS
) S ;

```

- **이는 ALIAS를 기존 테이블 이름과 동일하게 사용했기 때문임**
- 아래와 같은 경우는 잘 된다(No Alias)
```sql
SELECT
    NVL(TO_CHAR(BRANCH_ID), 'Total'),
    NVL(STATUS, '=========='),
    SUM(AMOUNT) AS SUM_AMOUNT
FROM LOANS
GROUP BY ROLLUP(BRANCH_ID, STATUS)
ORDER BY BRANCH_ID, STATUS;
```

- 혹은 다음과 같이 alias와 원래 테이블 명이 안겹치면 된다
```sql
SELECT
    NVL(TO_CHAR(BRANCH_ID), 'Total') as BRANCH_1,
    NVL(STATUS, '==========') AS STATUS_1,
    SUM(AMOUNT) AS SUM_AMOUNT
FROM LOANS
GROUP BY ROLLUP(BRANCH_ID, STATUS)
ORDER BY BRANCH_ID, STATUS;
```

### 정리

<aside>
💡

Group by 말고 현업에서 Partition by 쓰는 이유 : BALANCE와 같이 GROUP BY 대상하지 않는 COLUMN들도 활용할 수 있기 때문

</aside>

```sql
-- 4. 계좌 테이블에서 고객별 평균 잔액 계산
SELECT 
    DISTINCT CUSTOMER_ID,
    BALANCE,
    ROUND(AVG(BALANCE) OVER (PARTITION BY CUSTOMER_ID), 2) AS AVG_BALANCE
FROM ACCOUNTS
ORDER BY CUSTOMER_ID;

-- Group by version
SELECT 
CUSTOMER_ID,
ROUND(AVG(BALANCE), 2)
FROM ACCOUNTS
GROUP BY CUSTOMER_ID
ORDER BY CUSTOMER_ID;
```

## 계층 쿼리

- 데이터가 부모-자식 관계로 구성된 계층적 구조를 조회하기 위한 쿼리
- **트리 구조 데이터**를 표현하고 탐색하는 데 사용
- 주요 키워드 : `START WITH`, `CONNECT BY`, `PRIOR` , `ORDER SIBLINGS BY`, `SIBLINGS BY`, `LEVEL`
    - 그냥 `ORDER BY` 만 하면 계층 구조가 무너짐 ⇒ 같은 계층 구조에서 정렬해야 함

- `START WITH` : 계층 구조의 시작점 지정
- `CONNECT BY` : 부모-자식 관계를 정의
- `PRIOR` : 계층의 방향성을 설정
- `ORDER SIBLINGS BY` : 동일 레벨의 데이터 정렬
- `LEVEL` : 계층 깊이를 나타내는 가상 컬럼

```sql
SELECT 컬럼명, LEVEL
FROM 테이블명
START WITH 시작조건
CONNECT BY PRIOR 부모 컬럼 = 자식 컬럼;
```

```sql
-- 직원의 계층 깊이를 조회
SELECT EMPLOYEE_ID, NAME, LTRIM(SYS_CONNECT_BY_PATH(NAME, '->' ), '->') AS PATH
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;
```

```sql

-- 사번이 56인 직원의 상사들만 계층 구조로 조회(역방향 진행)
SELECT EMPLOYEE_ID, NAME, DEPARTMENT_ID
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 56
CONNECT BY EMPLOYEE_ID = PRIOR MANAGER_ID;
```

```sql
-- 계층 구조에서 동일한 부모를 가진 행들을 정렬
SELECT EMPLOYEE_ID, NAME, LEVEL
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
ORDER SIBLINGS BY NAME;
```

```sql
SELECT CATEGORY_ID, PARENT_CATEGORY_ID, CATEGORY_NAME, LEVEL, LTRIM(SYS_CONNECT_BY_PATH(CATEGORY_NAME, '>'), '>') AS CATE
FROM SHOPPING_CATEGORIES
START WITH PARENT_CATEGORY_ID IS NULL
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID;

-- ELECTRONICS 하위 카테고리만 조회
SELECT CATEGORY_ID, PARENT_CATEGORY_ID, CATEGORY_NAME, LEVEL, LTRIM(SYS_CONNECT_BY_PATH(CATEGORY_NAME, '>'), '>') AS CATE
FROM SHOPPING_CATEGORIES
START WITH CATEGORY_NAME = 'Electronics'
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID;
```

```sql
-- 둘 다 가능

SELECT CATEGORY_ID, CATEGORY_NAME, LEVEL
FROM SHOPPING_CATEGORIES
START WITH PARENT_CATEGORY_ID IS NULL
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID
GROUP BY CATEGORY_ID, CATEGORY_NAME, LEVEL
HAVING LEVEL = 2;

SELECT CATEGORY_ID, CATEGORY_NAME, LEVEL
FROM SHOPPING_CATEGORIES
WHERE LEVEL = 2
START WITH PARENT_CATEGORY_ID IS NULL
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID
GROUP BY CATEGORY_ID, CATEGORY_NAME, LEVEL;

```

```sql
-- 하위 카테고리가 없는 최하위 카테고리들만 조회
SELECT CATEGORY_ID, CATEGORY_NAME
FROM SHOPPING_CATEGORIES
WHERE CATEGORY_ID NOT IN (
    SELECT DISTINCT PARENT_CATEGORY_ID
    FROM SHOPPING_CATEGORIES
    WHERE PARENT_CATEGORY_ID IS NOT NULL
);
```

---

## 뷰

<aside>
💡

쿼리 결과만 저장 ⇒ 뷰와 연결된 테이블 내용 변경되면 쿼리 변경 가능

</aside>

- 단순 뷰 : 단일 테이블 기반
    - 거의 없음
- 복합 뷰
    - 대부분 사례
    - 여러 테이블, 함수 또는 그룹화 포함
- 물리적 뷰
    - 쿼리 결과를 물리적으로 저장하여 성능 향상
    - 실무에서 많이 쓰이지 않음

- 뷰 생성

```sql
CREATE VIEW [뷰 이름] AS
SELECT [COL 1, ... COL N] FROM [TABLE]
WHERE [CONDITION]
```

```sql
-- VIEW CREATE
CREATE OR REPLACE VIEW EMPLOYEE_VIEW AS
    SELECT EMPLOYEE_ID, NAME, JOB_ID, DEPARTMENT_ID, SALARY
    FROM EMPLOYEES
    WHERE MOD(DEPARTMENT_ID, 2) = 0;
    
-- VIEW SELECT
SELECT * FROM EMPLOYEE_VIEW WHERE SALARY > 1000;

-- VIEW UPDATE
UPDATE EMPLOYEE_VIEW
SET SALARY = 6000
WHERE EMPLOYEE_ID = 101;

SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = 101;

-- VIEW DELETE
DROP VIEW EMPLOYEE_VIEW;
```

- VIEW 업데이트 조건
    1. 뷰가 단일 테이블 기반
    2. PK 또는 고유 식별 칼럼 포함
    3. 뷰에 포함된 열이 기본 테이블의 실제 열
    4. GROUP BY, DISTINCT 또는 집계함수가 포함되지 않아야 함

# 시퀀스(Sequence)

- 자동으로 고유한 숫자를 생성하는 오라클 객체
- 주로 기본 키나 고유한 값이 필요한 컬럼에 사용
- `CREATE SEQUENCE` 명령어를 통해 생성

- 특징
    - 고유한 숫자 생성 보장
    - 숫자의 증가/감소 방향 설정 가능
    - `START WITH`, `INCREMENT BY` 등을 사용하여 생성 규칙 정의 가능
    - 캐싱을 사용하여 성능 최적화 기능

```sql
CREATE SEQUENCE EMPLOYEE_SEQ
START WITH 1
INCREMENT BY 1
MAXVALUE 99999
NOCACHE;

-- NEXTVAL : 다음 값을 반환
SELECT EMPLOYEE_SEQ.NEXTVAL FROM DUAL;

-- CURRVAL : 현재 값을 반환
SELECT EMPLOYEE_SEQ.CURRVAL FROM DUAL;
```

- INSERT가 실패해도, `NEXTVAL` 을 사용하면 실패하더라도 증가한다.

```sql
INSERT INTO EMPLOYEES (EMPLOYEE_ID, NAME)
VALUES (EMPLOYEE_SEQ.NEXTVAL, 'John Doe');
```

- SEQUENCE 조회

```sql
SELECT SEQUENCE_NAME, LAST_NUMBER
FROM USER_SEQUENCES;
```

- SEQUENCE 변경

```sql

ALTER SEQUENCE EMPLOYEE_SEQ
INCREMENT BY 5;
```

- SEQUENCE 삭제

```sql
DROP SEQUENCE EMPLOYEE_SEQ;
```

- SEQUENCE 사용 시 유의사항
    - DELETE 삭제된 값은 재사용되지 않음
    - 캐싱된 값은 장애 발생 시 손실 가능
    - NOCACHE 사용 시 성능 저하 가능

- 시퀀스 실제 활용 사례
    - 주문 번호 자동 생성
    - 고객 ID, 계좌 번호 생성
    - 대량 데이터 삽입 시 고유 키 생성
 
