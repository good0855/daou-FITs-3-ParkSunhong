# 1. Servlet 생명주기

- Client가 화면을 띄우는 과정
    1. HTML 내용을 DOM 구조 생성
    2. CSS 내용을 바탕으로 CSSOM 생성
    3. 1+2번 과정을 거친 결과물로 Render Tree 구성
- Server가 응답하는 과정
    - 우선 Servlet이 web server에서 처리할 수 있는지 was에서 처리할 수 있는지 파악 후 분기
    - was로 넘어오게 되면 httpRequest 객체가 넘어옴
    - ㄱ그리고 instance의 존재파악 및 생성 진행
        - init()을 통해 servelt instance 생성
    - thread invoker은 thread를 request 할당
    - 할당된 thread는 `service()` 를 호출
    - client가 보내준 요청에 대한 문자열 객체화(httpServletRequest)
    - `doGet()`, `doPost()` 는 thread가 실행

### **Client가 화면을 띄우는 과정**

1. **HTML 파싱 및 DOM 생성**
    - 브라우저가 서버로부터 HTML을 다운로드하고, 이를 기반으로 **DOM (Document Object Model)** 트리를 생성
2. **CSS 파싱 및 CSSOM 생성**
    - CSS 파일을 다운로드하고, 이를 기반으로 **CSSOM (CSS Object Model)** 트리를 생성
3. **Render Tree 생성 및 레이아웃 계산**
    - DOM과 CSSOM을 결합하여 **Render Tree** 생성
    - 브라우저는 각 요소의 크기와 위치를 계산하는 **레이아웃 단계(Layout 단계)** 진행
4. **페인팅(Painting) 및 화면 출력**
    - Render Tree를 기반으로 요소들을 **Rasterization** 후 **컴포지팅(Compositing)** 을 통해 최종적으로 화면에 출력

---

### **Server가 응답하는 과정**

1. **요청 처리 위치 결정**
    - Web Server(Nginx, Apache)에서 요청을 처리할지, WAS(Tomcat, Jetty 등)에서 처리할지 결정
2. **WAS(Servlet 컨테이너)로 요청 전달**
    - HTTP 요청을 **HttpServletRequest** 객체로 변환하여 WAS에 전달
3. **Servlet 인스턴스 확인 및 생성**
    - 요청에 해당하는 **Servlet 인스턴스가 존재하는지 확인**
    - 없으면 `init()` 메서드를 호출하여 **Servlet 객체 생성 및 초기화**
        - `init()`은 Servlet이 생성될 때 한 번만 호출됨
4. **Thread 할당 및 `service()` 실행**
    - 요청을 처리할 **Thread를 할당**하여 `service()` 메서드를 실행
    - `service()`는 HTTP 메서드(`GET`, `POST` 등)에 따라 `doGet()`, `doPost()` 등의 메서드 호출
5. **비즈니스 로직 처리 및 응답 반환**
    - 데이터베이스 조회, 로직 실행 후 **HttpServletResponse 객체 생성**
    - 클라이언트에게 **HTTP 응답 전송**

---

### **Servlet에서 Response 후 Thread의 처리 과정**

1. **Client에게 Response 전송**
    - `service()` → `doGet()` / `doPost()` 실행 후, `HttpServletResponse` 객체를 통해 응답 전송
    - 응답이 완료되면 WAS는 **OutputStream을 닫음**
2. **Thread 처리 방식 (쓰레드 풀 사용)**
    - WAS (Tomcat, Jetty 등)는 **Thread Pool**을 사용하여 요청을 처리
    - 응답이 완료되면 **해당 Thread는 종료되지 않고 Thread Pool로 반환됨**
    - 다음 요청이 들어오면 **재사용**되어 성능을 최적화
3. **Thread가 종료되는 경우**
    - 특정 시간 동안 요청이 없으면 **WAS가 일부 Thread를 정리**하여 자원 낭비 방지
    - WAS가 종료되면 모든 Thread도 종료됨

---

### **Servlet 생명주기 (Lifecycle)**

### 1️⃣ **서블릿 초기화 단계 (Initialization)**

- 최초 요청이 들어오면 Servlet 컨테이너가 **Servlet 인스턴스를 생성**
- `init()` 메서드 호출 (한 번만 실행됨)

### 2️⃣ **요청 처리 단계 (Request Handling)**

- 클라이언트가 요청을 보낼 때마다
    1. `service(HttpServletRequest, HttpServletResponse)` 호출
    2. HTTP 메서드에 따라 `doGet()`, `doPost()`, `doPut()`, `doDelete()` 등의 메서드 실행

### 3️⃣ **서블릿 종료 단계 (Destruction)**

- WAS가 종료되거나 필요하지 않게 되면 `destroy()` 호출 후 Servlet 인스턴스 제거

---

<aside>
💡

Servlet Class는 한 번 생성되면 계속 사용되는 싱글톤 방식으로 사용되기 때문에, 클래스 변수를 사용하지 말고 doGet, doPost 등 로직에서 지역적으로 사용해야 한다.

</aside>

# 2. 상태 저장

<aside>
💡

HTTP protocol은 기본적으로 무상태 프로토콜

</aside>

- Server은 기본적으로 Client를 구분할 수 없다. ⇒ 단순히 request를 처리하고 끝냄
- 그렇다면 상태를 저장하는 방법은?

## 1. 쿠키

- 구성요소
    - 문자열(ex. name=홍길동;age=20)
    - 유효기간
    - 유효 도메인
- 쿠키는 client web browser에 저장
- 쿠키의 단점
    - 보안성 X ⇒ 중요 정보 저장 불가
    - 문자열로 되어 있어 처리 쉽지 않음
    - 길이 제한 ⇒ 많은 데이터 저장 불가

## 2. 세션

- `HttpSession` 의 instance ⇒ 특정 클래스로부터 파생된 객체
- WAS에 저장(server-side)
- 쿠키를 이용
    - 서버에서 session을 주라고 클라이언트에 요청
    - 서버에서 SessionID를 쿠키에 넣어서 클라이언트에 저장 (1 client는 1 session)

## **1️⃣ 세션 생성 과정 (Client 최초 요청)**

### 🔹 **요청 흐름**

1. **Client가 Server에 최초 요청**
    - 사용자가 브라우저를 열고 웹사이트에 접속 (ex: 로그인 요청)
    - HTTP 요청을 보냄 (`HttpServletRequest`)
2. **Server가 Session 생성**
    - `HttpSession` 객체를 생성하여 사용자 정보를 저장
    - 세션 ID(`JSESSIONID`)를 생성
    - 세션 ID를 **Response Header의 `Set-Cookie`에 추가**하여 Client에 전송
3. **Client가 Response 받음**
    - 브라우저는 `Set-Cookie` 헤더를 통해 받은 `JSESSIONID`를 저장
    - 이후 요청에서 자동으로 **Cookie에 `JSESSIONID`를 포함하여 전송**

---

## **2️⃣ 세션을 이용한 요청 처리 (Client가 다시 요청할 때)**

### 🔹 **요청 흐름**

1. **Client가 동일한 서버에 두 번째 요청을 보냄**
    - 브라우저는 저장된 `JSESSIONID`를 요청 헤더의 `Cookie` 필드에 포함하여 전송
    - `GET /dashboard HTTP/1.1`
        
        ```
        Cookie: JSESSIONID=123456789ABCDEF
        
        ```
        
2. **Server가 세션 ID를 확인**
    - `HttpServletRequest.getSession()`을 호출하여 기존 세션을 조회
    - 존재하는 세션이라면 저장된 사용자 데이터를 사용하여 응답
3. **Server가 Response 반환**
    - 로그인된 사용자 정보를 유지한 상태에서 페이지 제공
    - 추가적인 데이터 저장이 필요하면 `session.setAttribute("key", value);` 사용

---

## **3️⃣ 세션 종료 과정 (만료 또는 로그아웃)**

### 🔹 **세션이 종료되는 경우**

1. **사용자가 로그아웃하면**
    - `session.invalidate();` 호출하여 세션 삭제
    - 클라이언트가 보낸 `JSESSIONID`가 더 이상 유효하지 않음
2. **세션이 일정 시간 동안 유지되지 않으면 자동 만료**
    - 기본적으로 WAS는 일정 시간이 지나면 세션을 삭제 (ex: Tomcat 기본 30분)
    - `web.xml`에서 `<session-timeout>` 설정 가능
    - ex) `<session-timeout>15</session-timeout>` → 15분 동안 요청 없으면 세션 만료
3. **서버가 재시작되면**
    - 세션 정보가 초기화됨 (단, 세션을 Redis 같은 외부 저장소에 저장하면 유지 가능)

---

## **4️⃣ Session을 유지하는 방법 (세션 클러스터링, DB 저장 등)**

대규모 시스템에서는 세션을 유지하기 위해 다양한 방법을 사용해.

| 방식 | 설명 |
| --- | --- |
| **Sticky Session** | 같은 사용자의 요청을 항상 같은 서버로 보내도록 설정 (Load Balancer 활용) |
| **Session Clustering** | 세션을 여러 서버에서 공유 (ex: Tomcat의 세션 복제) |
| **Session 저장소 사용** | Redis, Memcached 등에 세션 저장하여 유지 |
| **JWT (JSON Web Token)** | 서버가 세션을 저장하지 않고, 클라이언트가 토큰을 포함하여 요청 |

---

## **📌 최종 정리 (Client ↔ Server 통신 과정)**

### **1️⃣ Client가 최초 요청**

- `HTTP Request` (로그인 요청)
- Server는 `JSESSIONID` 생성 후 `Set-Cookie`에 포함하여 응답

### **2️⃣ 이후 요청에서 Client는 `JSESSIONID`를 포함하여 요청**

- `Cookie: JSESSIONID=123456789ABCDEF`
- Server는 해당 ID로 세션 조회 후 데이터 제공

### **3️⃣ 세션이 만료되거나 로그아웃 시 세션 삭제**

- `session.invalidate();` 호출
- 일정 시간 요청이 없으면 자동 만료

---

# 3. Session 예제

- `HttpServletRequest` 객체를 활용해서 진행

```java
// Session 설정
HttpSession session = req.getSession(); // default 인자 = true
session.setAttribute("member", member); // key-value 형태로 값 저장할 수 있다.
```

```java
req.getSession(false); 
// 기존에 할당된 session 객체가 이미 존재하면 가져다 주고
// 없으면 새로 만들지 말고 null return
```

```java
session.getAttribute(); // 값을 다시 꺼내올 수 있음
```

```java
session.invalidate(); // session 무효화 => session 객체 없앰
```

# 4. RequestDispatcher

- 하나의 servlet에서 다른 servlet을 호출하기 위함
- **클라이언트의 요청을 다른 리소스(예: 서블릿, JSP, HTML 파일 등)로 전달하는 역할**
- **`forward(request, response)`**: 현재 서블릿에서 처리한 요청을 다른 서블릿이나 JSP로 전달합니다. 이 방법은 클라이언트에게 새로운 URL로 이동하는 것이 아니라, 내부적으로 요청을 전달하는 방식입니다.
- **`include(request, response)`**: 다른 서블릿이나 JSP를 현재의 응답에 포함시켜서 클라이언트에게 전달합니다. 이 방법은 요청을 다른 리소스에 전달하되, 응답 내용은 현재 서블릿의 응답과 합쳐지게 됩니다.

# 5. JSP 문법

- JSP는 출력을 위한 작업만 진행해야 한다.
1. scriptlet
    - 일반 JAVA 코드가 나올 수 있음
    - `<% %>`
    
    ```java
    // type casting을 해야 함. 기본적으로 Object이기 때문임
    MemberVO member = (MemberVO) request.getAttribute("member");
    
    ```
    
2. expression
    - 문자열 출력
    - `<%= %>`

---

# 연습문제

- 로그인 게시판 구현
- 기능
    - 로그인
    - 로그아웃
    - 글 조회
    - 글 작성
    - 글 상세보기
    - 글 삭제
- 테이블
    - `members`
    - `boards`

![image.png](attachment:110b6c7a-ee47-4c6b-8385-9997c3785995:image.png)
