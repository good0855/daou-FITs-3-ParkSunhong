# TIL : 2025-01-16

## 학습 날짜 : 2024년 01월 16일

## 어떤 문제가 있었는지
- `JOIN` 문법 이해 어려움
- 기타 함수들 사용 어려움

## 그 문제를 해결하기 위해 내가 시도해본 것들
- 주어진 다양한 문제를 풀었다.

## 어떻게 그 문제를 해결했는지
- JOIN의 여러 종류를 실습하고, 단순히 JOIN만 사용하는 것이 아니라 데이터 및 도메인의 상황에 따라 다르게 적용하는 법을 배움
  - ex) null값 처리 등
  

## 오늘 내가 새롭게 배운 것들
- ROWNUM에 대한 실습
- `GROUP BY` : 집계함수가 적용된 열과 비집계열을 적용할 때, 비집계열은 반드시 `GROUP BY` 로 묶어주어야 함
- `HAVING` : 집계함수만 적용
- 날짜, 시간 적용 문제 적용 : `MONTH_BETWEEN` 등
### 문제
```sql

-- 1. 직원과 부서 정보 조회
-- 직원 이름과 소속 부서의 근무지를 조회해보세요
SELECT E.NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY E.EMPLOYEE_ID;

-- 2. 직원과 매니저 정보 조회
-- 직원 이름과 해당 직원의 매니저 이름을 조회하세요.
-- LEFT OUTER JOIN : 직원 위의 매니저가 존재 안할 수도 있음

SELECT
    E1.NAME AS EMPLOYEE_NAME,
    E2.NAME AS MANAGER_NAME
FROM EMPLOYEES E1
LEFT OUTER JOIN EMPLOYEES E2
ON E1.MANAGER_ID = E2.EMPLOYEE_ID
ORDER BY E1.EMPLOYEE_ID;

-- 3. 직원과 급여 정보 조회
-- 직원 이름과 급여를 조회하되, 급여가 NULL인 경우 "N/A" 로 출력
-- NVL2
SELECT
    NAME,
    NVL(TO_CHAR(SALARY), 'N/A') AS SALARY
FROM EMPLOYEES;

SELECT
    NAME,
    NVL2(SALARY, TO_CHAR(SALARY), 'N/A') AS SALARY
FROM EMPLOYEES;


-- 4. 특정 부서 직원 조회
-- 근무지가 Chicago인 직원 이름과 급여를 조회하세요.
SELECT E.NAME, E.SALARY
FROM EMPLOYEES E
INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE D.LOCATION = 'Chicago'
ORDER BY E.EMPLOYEE_ID;

SELECT E.NAME, E.SALARY
FROM EMPLOYEES E, DEPARTMENTS D
WHERE D.LOCATION = 'Chicago' AND E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY E.EMPLOYEE_ID;


-- 5. 특정 급여 범위 조회
-- 급여가 5000이상 10000이하인 직원의 이름과 급여, 부서명을 조회하세요
SELECT E.NAME, E.SALARY, D.DEPARTMENT_NAME
FROM EMPLOYEES E
INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.SALARY BETWEEN 5000 AND 10000
ORDER BY E.EMPLOYEE_ID;


-- 6. 최근 3개원 이내 입사한 직원 이름과 입사일을 조회하세요.
SELECT NAME, HIRE_DATE
FROM EMPLOYEES
WHERE ABS(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) <= 3
ORDER BY EMPLOYEE_ID;

-- 7. 각 부서의 부서장 이름 및 부서 이름 조회하기
SELECT
    D.DEPARTMENT_NAME,
    E.NAME AS MANAGER_NAME
FROM DEPARTMENTS D
LEFT OUTER JOIN EMPLOYEES E
ON D.MANAGER_ID = E.EMPLOYEE_ID
ORDER BY D.DEPARTMENT_ID;


-- 8. 직무별 직원 수 조회하기
SELECT
    JOB_ID,
    COUNT(JOB_ID) AS NUM_CNT
FROM EMPLOYEES
GROUP BY JOB_ID;

-- 9. 부서별 평균 급여
SELECT
    D.DEPARTMENT_ID,
    NVL(CEIL(AVG(E.SALARY)), 0) AS AVG_SALARY
FROM DEPARTMENTS D
LEFT OUTER JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_ID
ORDER BY D.DEPARTMENT_ID;

-- 10. 직원의 총 급여
SELECT
    SUM(SALARY) AS TOTAL_SALARY
FROM EMPLOYEES;

-- 11. 대출 금액과 고객 이름을 대출 금액이 높은 사람부터 조회하세요
SELECT
    C.NAME,
    L.AMOUNT
FROM CUSTOMERS C
INNER JOIN LOANS L
ON C.CUSTOMER_ID = L.CUSTOMER_ID
ORDER BY L.AMOUNT DESC;

-- 12. 대출 상태별 고객 수를 조회하세요. => DISTINCT 사용하기
SELECT
    STATUS,
    COUNT(DISTINCT CUSTOMER_ID) NUM_CUSTOMERS
FROM LOANS
GROUP BY STATUS;

-- 13. 직원 수가 가장 적은 부서의 부서 ID와 직원 수 조회

--SELECT DEPARTMENT_ID, COUNT(DEPARTMENT_ID) AS NUM_EMPLOYEES
--FROM EMPLOYEES
--GROUP BY DEPARTMENT_ID
--ORDER BY NUM_EMPLOYEES;


SELECT 
    D.DEPARTMENT_ID,
    COUNT(E.DEPARTMENT_ID) AS CNT
FROM DEPARTMENTS D
LEFT OUTER JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_ID
ORDER BY CNT ASC;
FETCH FIRST 1 ROWS ONLY;

SELECT * FROM
(SELECT DEPARTMENT_ID, COUNT(*)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID
ORDER BY COUNT(*)
)
WHERE ROWNUM = 1;


-- 14. 월별 신규 고객 수를 최근순으로 조회
SELECT
    TO_CHAR(CREATED_AT, 'YYYY-MM') AS YEAR_MONTH,
    COUNT(CUSTOMER_ID) AS CNT
FROM CUSTOMERS
GROUP BY TO_CHAR(CREATED_AT, 'YYYY-MM')
ORDER BY YEAR_MONTH DESC;


-- 15. 상품 카테고리와 상위 카테고리를 조회하세요(단, 상위 카테고리가 없는 데이터도 조회)
SELECT 
    L.CATEGORY_NAME AS LOWER,
    U.CATEGORY_NAME AS PARENT
FROM
SHOPPING_CATEGORIES L
LEFT OUTER JOIN SHOPPING_CATEGORIES U
ON L.PARENT_CATEGORY_ID = U.CATEGORY_ID;


SELECT 
    C1.CATEGORY_NAME,
    C2.CATEGORY_NAME,
    C3.CATEGORY_NAME
FROM SHOPPING_CATEGORIES C1
LEFT OUTER JOIN SHOPPING_CATEGORIES C2
ON C1.PARENT_CATEGORY_ID = C2.CATEGORY_ID
LEFT OUTER JOIN SHOPPING_CATEGORIES C3
ON C2.PARENT_CATEGORY_ID = C3.CATEGORY_ID;



SELECT ROWNUM, EMPLOYEES.* FROM EMPLOYEES
WHERE ROWNUM <= 10;

SELECT E.*
FROM (
    SELECT ROWNUM AS RN, EMPLOYEES.*
    FROM EMPLOYEES
) E
WHERE RN BETWEEN 6 AND 10;



-- 16. 특정 지점의 대출 합계
-- BRANCH 8 지점의 대출 총합을 조회하세요(소수점아래 버림)
SELECT
    B.NAME,
    FLOOR(SUM(L.AMOUNT)) AS SUM_LOAN
FROM BRANCHES B
INNER JOIN LOANS L
ON B.BRANCH_ID = L.BRANCH_ID
WHERE B.NAME = 'Branch 8'
GROUP BY B.NAME;

-- 차이 찾아보기!

SELECT
    FLOOR(SUM(L.AMOUNT)) AS SUM_LOAN
FROM BRANCHES B
INNER JOIN LOANS L
ON B.BRANCH_ID = L.BRANCH_ID
WHERE B.NAME = 'Branch 8';

-- 17. 직무별 직원의 평균 급여 계산 => 평균 급여가 5000이상인 경우만 출력
-- 평균 급여가 8000이상인 경우 HIGH, ~~
-- 평균 급여가 높은 순으로 정렬
SELECT
    JOB_ID,
    CASE
        WHEN AVG(SALARY) >= 8000 THEN 'HIGH'
        WHEN AVG(SALARY) >= 6000 THEN 'MEDIUM'
        ELSE 'LOW'
    END AS AVG_SALARY,
    AVG(SALARY) AS AVG_SALARY2
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING AVG(SALARY) >= 5000
ORDER BY AVG_SALARY2 DESC;


-- 18.고객 이름과 총 거래 내역(금액)을 조회하여 고객 이름으로 오름차순
SELECT
    C.NAME,
    NVL(SUM(L.AMOUNT), 0)
FROM CUSTOMERS C
LEFT OUTER JOIN LOANS L
ON C.CUSTOMER_ID = L.CUSTOMER_ID
GROUP BY C.CUSTOMER_ID, C.NAME
ORDER BY C.NAME;

SELECT 
    C.NAME,
    NVL(SUM(A.BALANCE), 0) AS TOTAL_SUM
FROM CUSTOMERS C
LEFT OUTER JOIN ACCOUNTS A
ON C.CUSTOMER_ID = A.CUSTOMER_ID
LEFT OUTER JOIN TRANSACTIONS T
ON A.ACCOUNT_ID = T.ACCOUNT_ID
GROUP BY C.NAME
ORDER BY TO_NUMBER(SUBSTR(C.NAME, 10, LENGTH(C.NAME)));


-- 19. 부서별 직원의 평균 입사일
-- 부서별로 평균 근속일을 계산하여 부서이름으로 오름차순 정렬
-- 단, 평균 근속일은 반올림하여 정수로 표현
SELECT
    D.DEPARTMENT_NAME,
    ROUND(AVG(TRUNC(SYSDATE) - E.HIRE_DATE)) AS AVG_HIRE_DAYS
FROM EMPLOYEES E
INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME
ORDER BY D.DEPARTMENT_NAME ASC;



-- 20. 대출 금액이 가장 높은 상위 5명의 고객의 이름과 대출 금액 조회
-- 단, 대출 금액이 동일한 경우 고객의 이름으로 오름차순


SELECT NAME, TOTAL_AMOUNT
FROM (
    SELECT C.NAME, SUM(L.AMOUNT) AS TOTAL_AMOUNT
    FROM CUSTOMERS C
    INNER JOIN LOANS L
    ON C.CUSTOMER_ID = L.CUSTOMER_ID
    GROUP BY C.CUSTOMER_ID, C.NAME
    ORDER BY TOTAL_AMOUNT DESC, C.NAME ASC
)
WHERE ROWNUM <= 5;

```
