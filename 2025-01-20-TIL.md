## 2025-01-20 TIL

# 연관 여부에 따른 분류

## 비연관 서브쿼리

- 서브쿼리가 독립적으로 실행되어 결과를 반환
- 메인 쿼리와 서브쿼리 간 상호작용 없음
- 평균 급여보다 높은 급여를 받는 직원 조회
    
    ```sql
    SELECT NAME
    FROM EMPLOYEES
    WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEEES);
    ```
    

## 연관 서브쿼리

- 서브쿼리가 메인 쿼리의 각 행마다 실행
- 메인 쿼리의 데이터를 서브쿼리에서 참조
- 예시 : 동일한 부서에서 급여가 가장 높은 직원 조회

```sql
SELECT NAME FROM EMPLOYEES E1
WHERE SALARY = (
SELECT MAX(SALARY)
FROM EMPLOYEES E2
WHERE E1.DEPARTMENT_ID = E2.DEPARTMENT_ID);
```

# 위치에 따른 분류

## 스칼라 서브쿼리

- 서브쿼리가 **컬럼 값**으로 반환되어 SELECT 절에서 사용
- 주로 집계 값이나 계산 결과를 포함할 때 활용
- 예시 : 각 직원의 급여와 해당 부서의 평균 급여를 조회

```sql
SELECT NAME, SALARY, 
(SELECT AVG(SALARY) FROM EMPLOYEES
WHERE DEPARTMENT_ID = E.DEPARTMENT_ID) AS AVG_SALARY
FROM EMPLOYEES E;
```

## 인라인 뷰

- FROM절에서 서브쿼리 결과를 **테이블**처럼 사용
- 별칭 붙여 사용 가능
- 예시 : 부서별 평균 급여 계산 ⇒ 각 부서의 이름과 평균 급여를 조회

```sql
SELECT DEPARTMENT_NAME, T.AVG_SALARY
FROM DEPARTMENT D, 
(SELECT DEPARTENT_ID, AVG(SALARY), AS AVG_SALARY
FROM EMPLOYEES GROUP BY DEPARTMENT) T
WHERE DEPARTMENT_ID = T.DEPARTMENT_ID;
```

## 중첩 서브쿼리

- WHERE절에서 조건을 설정하기 위해 사용
- 서브쿼리 결과에 따라 메인쿼리의 필터링 결정
- 예 : 특정 부서에 속한 직원 조회

```sql
SELECT NAME
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID
FROM DEPARTMENTS
WHERE DEPARTMENT_NAME = 'Department 1');
```

- 아래 예시는 HAVING 절에서 쓰는 예시이다.
- 예 : 평균 급여 이상인 부서의 총 급여 조회

```sql
SELECT DEPARTMENT_ID, SUM(SALARY) AS TOTAL_SALARY
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING SUM(SALARY) > (
SELECT AVG(SUM(SALARY))
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID);
```

# 반환값 유형에 따른 분류

## 단일 행 서브쿼리

- 서브쿼리가 단일 행과 열을 반환
- 비교 연산자와 함께 사용
- 예 : 가장 높은 급여를 받는 직원 조회

```sql
SELECT NAME
FROM EMPLOYEES
WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEES);
```

## 다중 행 서브쿼리

- 서브쿼리가 여러 행을 반환
- 다중행 연산자(IN, ANY, ALL)와 함께 사용
- 예시 : 특정 부서들에 속한 직원 조회

 

```sql
SELECT NAME
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID 'New York');
```

## 다중 열 서브쿼리

- 서브쿼리가 여러 열은 반환
- 예 : 특정 부서와 직무를 가진 직원 조회

```sql

```

## 서브쿼리 사용시 유의사항

### 1. 성능 최적화

- 비연관 서브쿼리는 독립적으로 실행되므로 더 빠름
- 연관 서브쿼리는 메인 쿼리의 각 행마다 실행되므로 성능 저하 가능

### 2. 적절한 반환값 확인

- 서브쿼리가 반환하는 값의 유형(단일, 다중 값)에 따라 연산자 선택이 중요

### 3. JOIN 대체 가능성

- 일부 서브쿼리는 JOIN으로 대체할 수 있어 성능 개선 가능성
-
- **윈도우 : 특정 범위**
- 집계함수와 함께 데이터를 그룹핑하지 않고도 계산 가능
- 주요 용도
    - 순위 계산
    - 이동 평균
    - 누적 합계
    - 그룹별 최댓값, 최솟값

```sql
SELECT
    EMPLOYEE_ID,
    NAME,
    SALARY,
    RANK() OVER (ORDER BY SALARY DESC NULLS LAST) AS rank
FROM EMPLOYEES;
```

- RANK를 `WHERE` 에서 활용

```sql
SELECT * FROM ( 
    SELECT
        DEPARTMENT_ID,
        EMPLOYEE_ID,
        NAME,
        SALARY,
        RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC NULLS LAST) AS rank
    FROM EMPLOYEES
)
WHERE RANK = 1;
```

## 윈도우 집계 함수 기본 문법

- 

```sql
SELECT 컬럼명
집계함수() OVER (PARTITION BY 컬럼
								ORDER BY 컬럼 ASC) AS 결과칼럼
FROM 테이블명
```

```sql
-- SUM 함수 예제
SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY, SUM(SALARY) OVER
(PARTITION BY DEPARTMENT_ID) AS DEPT_TOTAL
FROM EMPLOYEES;

-- 누적합
SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY, SUM(SALARY) OVER
(PARTITION BY DEPARTMENT_ID ORDER BY SALARY) AS DEPT_TOTAL
FROM EMPLOYEES;

-- 부서별로 평균
SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY, AVG(SALARY) OVER
(PARTITION BY DEPARTMENT_ID) AS DEPT_AVG
FROM EMPLOYEES;

-- 부서별로 최대값
SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY, MAX(SALARY) OVER
(PARTITION BY DEPARTMENT_ID) AS DEPT_MAX
FROM EMPLOYEES;

-- 부서에서 최댓값 하나만 뽑기
SELECT * FROM (
    SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY, MAX(SALARY) OVER
    (PARTITION BY DEPARTMENT_ID) AS DEPT_MAX
    FROM EMPLOYEES
)WHERE DEPT_MAX = SALARY;

-- 부서별 최소 급여를 계산
SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
MIN(SALARY) OVER
(PARTITION BY DEPARTMENT_ID) AS DEPT_MIN
FROM EMPLOYEES;

-- 부서별 직원 수 계산
SELECT EMPLOYEE_ID, DEPARTMENT_ID, SALARY,
COUNT(SALARY) OVER
(PARTITION BY DEPARTMENT_ID) AS DEPT_COUNT
FROM EMPLOYEES;
```

## PARTITION BY와 ORDER BY

- PARTITION BY
    - 데이터를 특정 그룹으로 나눔
    - 그룹별로 윈도우 함수가 작동
- ORDER BY
    - 데이터를 정렬하여 윈도우 함수의 동작 순서를 지정
    - 누적 계산에 주로 사용

## 윈도우 함수 옵션

- ROWS
- RANGE
- UNBOUNDED PRECEDING
- CURRENT ROW
- FOLLOWING

### SQL 추가문제제
```sql

-- 1. 직원과 부서 정보를 조합하여 직무와 급여 통계
-- 모든 부서에서 직무별 평균 급여와 해당 직무에서 가장 높은 급여를 계산하세요.
-- 결과는 부서 이름, 직무 ID, 평균 급여, 최대 급여로 출력되며, 평균 급여가 8000 이상인 결과만 조회하세요.
-- 결과는 평균 급여 기준으로 내림차순 정렬하고 평균 급여는 반올림하여 소수점 아래 둘째자리까지 표현합니다. (스칼라 서브 쿼리 사용)
SELECT
    (
        SELECT D.DEPARTMENT_NAME
        FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID
    ) DEPARTMENT,
    E.JOB_ID AS JOB_ID,
    ROUND(AVG(E.SALARY), 2) AS AVG_SALARY,
    MAX(E.SALARY) AS MAX_SALARY
FROM EMPLOYEES E
GROUP BY E.DEPARTMENT_ID, E.JOB_ID
HAVING AVG(E.SALARY) >= 8000
ORDER BY AVG_SALARY DESC;


-- 2.5년 이내에 입사한 직원들의 급여와 전체 직원 급여 비교
-- 최근 5년 이내에 입사한 직원들의 부서별 평균 급여와 전직원들의 평균 급여를 비교하여,
-- 최근 5년 내에 입사한 직원들의 급여가 더 높은 경우에 해당하는 부서 이름과 해당 부서 평균 급여를 조회하세요. 
-- (단, 부서 평균 급여는 올림하여 정수로 나타냅니다.)

SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;
-- 최근 5년 구하기


SELECT
    D.DEPARTMENT_NAME,
    CEIL(EE.AVG_SALARY)
FROM DEPARTMENTS D,
    -- 5년 내에 입사한 부서별 직원들의 평균 급여 
    (SELECT
        DEPARTMENT_ID,
        AVG(SALARY) AS AVG_SALARY
    FROM EMPLOYEES
    WHERE ADD_MONTHS(SYSDATE,-60) - HIRE_DATE <= 5
    GROUP BY DEPARTMENT_ID
    ) EE
WHERE
    D.DEPARTMENT_ID = EE.DEPARTMENT_ID AND -- INNER JOIN
    EE.AVG_SALARY >= (SELECT AVG(SALARY) FROM EMPLOYEES) ;


-- 3. 특정 지역의 지점에서 대출을 받은 고객 조회
-- 위치(Location)가 'Location 4'인 지점에서 대출을 받은 고객 중 대출 금액이 50,000 이상인 고객의 이름, 대출 금액, 대출 상태를 조회하세요.

SELECT C.NAME, L.AMOUNT, L.STATUS
FROM CUSTOMERS C, LOANS L
WHERE C.CUSTOMER_ID IN (
    SELECT CUSTOMER_ID FROM LOANS
    WHERE BRANCH_ID IN (
        SELECT BRANCH_ID FROM BRANCHES
        WHERE LOCATION = 'Location 4'
    )
)
AND C.CUSTOMER_ID = L.CUSTOMER_ID
AND L.AMOUNT >= 50000;


-- 4. 대출 상태가 'PENDING'인 고객과 'REJECTED'인 고객의 교집합
-- 대출 상태가 'REJECTED'인 고객과 'PENDING'인 고객 중 두 상태 모두 해당되는 고객의 이름과 이메일, 전화번호를 조회하세요
SELECT
    NVL(NAME, 'N/A')AS NAME,
    NVL(EMAIL, 'N/A') AS EMAIL,
    NVL(PHONE, 'N/A') AS PHONE
FROM CUSTOMERS
WHERE CUSTOMER_ID IN (
    SELECT CUSTOMER_ID FROM LOANS
    WHERE STATUS = 'PENDING'
    UNION
    SELECT CUSTOMER_ID FROM LOANS
    WHERE STATUS = 'REJECTED'
);


-- 5. 대출 상태와 계좌 잔액 통계 병합
-- 계좌 잔액이 50,000 이상인 고객과 대출 상태가 'PENDING'인 고객을 병합하여 결과를 조회하세요.
-- 출력 데이터는 [고객 이름], [계좌 잔액 및 대출 금액 = 동일 컬럼] 이며 헤더명은 “고객 이름”, “금액” 으로 표시하고 고객 이름으로 오른차순 정렬합니다.
--SELECT 
--    NAME AS '고객이름',
--    BA
--FROM CUSTOMERS
--WHERE CUSTOMER_ID IN (

SELECT
    NAME AS "고객 이름",
    BALANCE AS "금액"
FROM 
CUSTOMERS C
INNER JOIN (
    SELECT CUSTOMER_ID, BALANCE FROM ACCOUNTS
    WHERE BALANCE >= 50000
    UNION ALL
    SELECT CUSTOMER_ID, AMOUNT AS BALANCE FROM LOANS
    WHERE STATUS = 'PENDING'
    ) D
ON C.CUSTOMER_ID = D.CUSTOMER_ID
ORDER BY "고객 이름" ASC;

```
