## Layered Architecture

1. Presentation Layer : 사용자의 입출력 담당
2. Business Layer : 로직 처리
3. Persistence Layer : 데이터베이스 처리 전담(ex. JDBC)
4. Database Layer : 실제 DB 지칭

## Model

- Data Model → VO
- Service Model → 조직처리하는 객체

## View

- 입출력을 담당(조직처리 X)

## Controller

- 중간 매개체 연결
- view와 service 연결

<aside>
💡

DAO : DB Access 처리만 허용

</aside>

---

# DAO

- step1 : 일반적인 DAO
    - 중복 코드 존재
- step2 : 중복된 코드를 메소드로 분리 ⇒ 유시보수성 향상
- step3 : 추상 메소드와 추상 클래스로 만들어서 제공한다.
    - 가져가서 사용하는 사람을 상속해서 사용
    - 상위 클래스(`UserDAO` )에서 기본적인 로직은 구현하고 하위 클래스(`KUserDAO` )에서 구체적인 구현 내용을 변경해서 구현**(Template Method Pattern)**
    - 그러나 단일상속문제 때문에 사용이 불가능한 경우도 있어요
- 상속을 배제하고 재활용할 수 있는 방법?
    - UserDAO의 변해야 하는 부분은 별도의 code로 분리

## MVC Pattern주의할 점

- Service Layer은 반드시 transaction관리를 해주어야 함.
- DAO layer은 단위 쿼리를 관리해야 함

```java
    @Override
    public ObservableList<BookVO> searchBooks(String keyword) throws SQLException, ClassNotFoundException {
        Connection con = ConnectionManager.getConnection();
        // 트랜잭션 설정
        con.setAutoCommit(false);

        ObservableList<BookVO> books = bookDAO.search(keyword);

        if (books == null) {
            con.rollback();
        } else {
            con.commit();
        }

        con.close();
        // 트랜잭션 설정 구간 끝
        return books;
    }
```
