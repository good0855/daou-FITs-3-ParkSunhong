## 2025-01-25-TIL
<aside>
💡

Group by 말고 현업에서 Partition by 쓰는 이유 : BALANCE와 같이 GROUP BY 대상하지 않는 COLUMN들도 활용할 수 있기 때문

</aside>

```sql
-- 4. 계좌 테이블에서 고객별 평균 잔액 계산
SELECT 
    DISTINCT CUSTOMER_ID,
    BALANCE,
    ROUND(AVG(BALANCE) OVER (PARTITION BY CUSTOMER_ID), 2) AS AVG_BALANCE
FROM ACCOUNTS
ORDER BY CUSTOMER_ID;

-- Group by version
SELECT 
CUSTOMER_ID,
ROUND(AVG(BALANCE), 2)
FROM ACCOUNTS
GROUP BY CUSTOMER_ID
ORDER BY CUSTOMER_ID;
```

## 계층 쿼리

- 데이터가 부모-자식 관계로 구성된 계층적 구조를 조회하기 위한 쿼리
- **트리 구조 데이터**를 표현하고 탐색하는 데 사용
- 주요 키워드 : `START WITH`, `CONNECT BY`, `PRIOR` , `ORDER SIBLINGS BY`, `SIBLINGS BY`, `LEVEL`
    - 그냥 `ORDER BY` 만 하면 계층 구조가 무너짐 ⇒ 같은 계층 구조에서 정렬해야 함

- `START WITH` : 계층 구조의 시작점 지정
- `CONNECT BY` : 부모-자식 관계를 정의
- `PRIOR` : 계층의 방향성을 설정
- `ORDER SIBLINGS BY` : 동일 레벨의 데이터 정렬
- `LEVEL` : 계층 깊이를 나타내는 가상 컬럼

```sql
SELECT 컬럼명, LEVEL
FROM 테이블명
START WITH 시작조건
CONNECT BY PRIOR 부모 컬럼 = 자식 컬럼;
```

```sql
-- 직원의 계층 깊이를 조회
SELECT EMPLOYEE_ID, NAME, LTRIM(SYS_CONNECT_BY_PATH(NAME, '->' ), '->') AS PATH
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;
```

```sql

-- 사번이 56인 직원의 상사들만 계층 구조로 조회(역방향 진행)
SELECT EMPLOYEE_ID, NAME, DEPARTMENT_ID
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 56
CONNECT BY EMPLOYEE_ID = PRIOR MANAGER_ID;
```

```sql
-- 계층 구조에서 동일한 부모를 가진 행들을 정렬
SELECT EMPLOYEE_ID, NAME, LEVEL
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
ORDER SIBLINGS BY NAME;
```

```sql
SELECT CATEGORY_ID, PARENT_CATEGORY_ID, CATEGORY_NAME, LEVEL, LTRIM(SYS_CONNECT_BY_PATH(CATEGORY_NAME, '>'), '>') AS CATE
FROM SHOPPING_CATEGORIES
START WITH PARENT_CATEGORY_ID IS NULL
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID;

-- ELECTRONICS 하위 카테고리만 조회
SELECT CATEGORY_ID, PARENT_CATEGORY_ID, CATEGORY_NAME, LEVEL, LTRIM(SYS_CONNECT_BY_PATH(CATEGORY_NAME, '>'), '>') AS CATE
FROM SHOPPING_CATEGORIES
START WITH CATEGORY_NAME = 'Electronics'
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID;
```

```sql
-- 둘 다 가능

SELECT CATEGORY_ID, CATEGORY_NAME, LEVEL
FROM SHOPPING_CATEGORIES
START WITH PARENT_CATEGORY_ID IS NULL
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID
GROUP BY CATEGORY_ID, CATEGORY_NAME, LEVEL
HAVING LEVEL = 2;

SELECT CATEGORY_ID, CATEGORY_NAME, LEVEL
FROM SHOPPING_CATEGORIES
WHERE LEVEL = 2
START WITH PARENT_CATEGORY_ID IS NULL
CONNECT BY PRIOR CATEGORY_ID = PARENT_CATEGORY_ID
GROUP BY CATEGORY_ID, CATEGORY_NAME, LEVEL;

```

```sql
-- 하위 카테고리가 없는 최하위 카테고리들만 조회
SELECT CATEGORY_ID, CATEGORY_NAME
FROM SHOPPING_CATEGORIES
WHERE CATEGORY_ID NOT IN (
    SELECT DISTINCT PARENT_CATEGORY_ID
    FROM SHOPPING_CATEGORIES
    WHERE PARENT_CATEGORY_ID IS NOT NULL
);
```

## 오늘 문제

```sql
--1. 직무별 상위 3명의 직원
--각 직무별로 급여가 가장 높은 3명의 직원 정보를 조회하세요. 출력 컬럼은 직무, 사번, 이름, 급여, 순위이고 직무, 순위로 정렬합니다.
SELECT * FROM
    (SELECT 
        JOB_ID,
        EMPLOYEE_ID,
        NAME,
        SALARY,
        RANK() OVER (PARTITION BY JOB_ID ORDER BY JOB_ID DESC, SALARY DESC) AS RANK
    FROM
        EMPLOYEES
        WHERE SALARY IS NOT NULL
        )
WHERE RANK <= 3;
```

```sql
--2. 직원 입사 연도별 총 급여 및 누적 급여
--직원들의 입사 연도별 총 급여와 해당 연도의 누적 급여를 계산하세요.

SELECT
    EXTRACT(YEAR FROM HIRE_DATE) AS HIRE_YEAR,
    SUM(SALARY) AS TOTAL_SALARY,
    SUM( SUM(SALARY)  ) OVER (ORDER BY EXTRACT(YEAR FROM HIRE_DATE)) AS CUMULATIVE_SALARY
FROM EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
ORDER BY HIRE_YEAR;

```

```sql
SELECT YEAR, TOTAL_SUM, SUM(TOTAL_SUM) OVER (ORDER BY YEAR) AS PREFIX_SUM
FROM (
    SELECT 
        EXTRACT(YEAR FROM HIRE_DATE) AS YEAR,
        SUM(SALARY) AS TOTAL_SUM
        FROM EMPLOYEES
        GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
);
```

```sql
--3. 직원별 급여 순위와 부서 평균 급여 비교
--모든 직원에 대해 급여 순위를 계산하고, 각 직원의 급여가 부서 평균 급여보다 높은지 확인하세요.
-- 부서 평균 급여보다 높은 경우 ‘높다’라고 출력하고 낮은 경우 ‘낮다’라고 출력합니다. (출력 컬럼은 사번, 이름, 급여, 급여 순위, 부서 평균 급여, 높은지 낮은지 여부)
SELECT
    EMPLOYEE_ID,
    NAME,
    SALARY,
    RANK() OVER (ORDER BY SALARY DESC NULLS LAST) AS RANK,
    ROUND(AVG(SALARY) OVER(PARTITION BY DEPARTMENT_ID), 2) AS AVG_SALARY,
    CASE
        WHEN SALARY >= AVG(SALARY) OVER(PARTITION BY DEPARTMENT_ID) THEN '높다'
        ELSE '낮다'
    END AS OVER
FROM EMPLOYEES;
```

```sql
--4. 최근 1년간 대출을 받은 고객 중 총 대출 금액 상위 5명
--최근 1년 동안 대출을 받은 고객의 총 대출 금액을 계산하고, 이 금액이 상위 5명인 고객의 이름과 대출 금액을 출력하세요.


SELECT 
    C.NAME,
    S.CUSTOMER_ID,
    S.SUM_AMOUNT,
    S.LOAN_DATE
FROM CUSTOMERS C
INNER JOIN (
    SELECT * FROM (
        SELECT  
            DISTINCT CUSTOMER_ID,
            SUM(AMOUNT) OVER(PARTITION BY CUSTOMER_ID) AS SUM_AMOUNT,
            LOAN_DATE
        FROM LOANS
        WHERE ADD_MONTHS(SYSDATE, -12) - LOAN_DATE <= 1
        AND STATUS = 'APPROVED'
        ORDER BY SUM_AMOUNT DESC
    
    )
    WHERE ROWNUM <= 5
) S
ON C.CUSTOMER_ID = S.CUSTOMER_ID;
```


```sql
--5. 이동 평균 (Moving Average)
--직원 테이블에서 직원의 급여(SALARY)를 기준으로 / 직원 ID 순서대로 3명의 이동 평균을 계산하세요.
-- 여기서 이동 평균은 현재 직원의 급여와 바로 이전 직원 2명의 급여를 포함합니다.
-- 직원 ID, 이름, 급여, 그리고 이동 평균을 출력하세요. 이동 평균값은 반올림하여 소수점 아래 둘째 자리까지 표현합니다
SELECT
    EMPLOYEE_ID,
    NAME,
    SALARY,
    ROUND(AVG(SALARY) OVER(ORDER BY EMPLOYEE_ID ASC ROWS BETWEEN 2 PRECEDING AND CURRENT ROW), 2) AS MOVING_AVG
FROM EMPLOYEES;
```

```sql
-- 6. 계좌 잔액이 평균 잔액 이상인 고객과 대출 금액이 평균 대출 금액 이상인 고객의 병합
-- 계좌 잔액이 전 계좌의 평균 잔액 이상인 고객과 대출 금액이 평균 대출 금액 이상인 고객을 병합하여
-- 고객 이름과 금액을 조회하세요. 
-- 출력 데이터에 출처가 "계좌" 인지 "대출"인지도 하나의 칼럼으로 나타내주세요.
SELECT 
    C.NAME AS NAME,
    A.BALANCE AS AMOUNT,
    '계좌' AS TYPE
FROM CUSTOMERS C, ACCOUNTS A
WHERE C.CUSTOMER_ID = A.CUSTOMER_ID
AND A.BALANCE >= (SELECT AVG(BALANCE) AS AVG_BALANCE FROM ACCOUNTS)

UNION 

SELECT C.NAME, L.AMOUNT, '대출' AS TYPE
FROM CUSTOMERS C, LOANS L
WHERE C.CUSTOMER_ID = L.CUSTOMER_ID
AND L.AMOUNT >= (SELECT AVG(AMOUNT) AS AVG_LOANS FROM LOANS)
ORDER BY NAME ASC;
```

```sql
-- 7. 직무별 평균 급여가 부서별 평균 급여 이상인 직무 조회
-- 직무별 평균 급여가 소속된 부서의 평균 급여 이상인 경우를 조회하세요. 
-- 출력 데이터는 직무 ID, 부서 이름, 직무별 평균 급여, 부서별 평균 급여입니다.
-- 각 평균 급여는 반올림하여 정수로 표현해주세요.
SELECT 
    S.JOB_ID,
    D.DEPARTMENT_NAME,
    ROUND(S.AVG_JOB_SALARY, 0),
    ROUND(S.AVG_DEPARTMENT_SALARY, 0)
FROM
DEPARTMENTS D
INNER JOIN (
    SELECT 
        DISTINCT JOB_ID,
        DEPARTMENT_ID,
        AVG(SALARY) OVER(PARTITION BY JOB_ID) AS AVG_JOB_SALARY, -- 직무별 평균 급여
        AVG(SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS AVG_DEPARTMENT_SALARY -- 부서별 평균 급여
    FROM EMPLOYEES
    WHERE DEPARTMENT_ID IS NOT NULL
) S
ON D.DEPARTMENT_ID = S.DEPARTMENT_ID
WHERE S.AVG_JOB_SALARY >= S.AVG_DEPARTMENT_SALARY;
```
```sql
-- 8. 지점별 고객 수와 숭인율
-- 지점별 대출 건수를 계산하고 대출 승인율(APPROVED 생태 건수 / 전체 건수 * 100) 을 계산하여 결과를 출력하세요.
-- 대출 승인율은 반올림하여 소수 둘째자리까지 표현

SELECT
    BRANCH_ID,
    COUNT(LOAN_ID) AS TOTAL_LOANS,
    COUNT(CASE WHEN STATUS = 'APPROVED' THEN 1 END) AS APPROVED_LOANS,
    ROUND(
        (COUNT(CASE WHEN STATUS = 'APPROVED' THEN 1 END) * 100.0 / COUNT(*)), 
        2
    ) AS APPROVAL_RATE
FROM LOANS
GROUP BY BRANCH_ID
ORDER BY BRANCH_ID;
```

```sql
-- 9. 직무별 최고 급여를 받는 직원

SELECT NAME, SALARY FROM EMPLOYEES
WHERE (JOB_ID, SALARY) IN
(
    SELECT JOB_ID, MAX(SALARY) OVER(PARTITION BY JOB_ID) AS MAX_SALARY FROM EMPLOYEES
)
ORDER BY JOB_ID;
```

```sql
-- 10. 상사와 직원 관계를 기반으로 부서별 직원 통계
-- 각 부서에서 상사가 있는 직원의 수와 상사가 없는 직원의 수를 계산하세요. 부서 이름에서 각 통계 값을 출력하세요.

SELECT 
    (
        SELECT DEPARTMENT_NAME
        FROM DEPARTMENTS
        WHERE DEPARTMENT_ID = E.DEPARTMENT_ID
    ),

    COUNT(CASE WHEN MANAGER_ID IS NOT NULL THEN 1 END) HAVE_MANAGER,
    COUNT(CASE WHEN MANAGER_ID IS NULL THEN 1 END) NO_MANAGER 
FROM EMPLOYEES E
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;
        

SELECT D.DEPARTMENT_ID,
    NVL(SUM(S.HAVE_MANAGER), 0) AS MANAGER_COUNT,
    NVL(COUNT(S.EMPLOYEE_ID) - SUM(S.HAVE_MANAGER), COUNT(S.EMPLOYEE_ID)) AS NON_MANAGER_COUNT
FROM DEPARTMENTS D
INNER JOIN (
    SELECT 
        DEPARTMENT_ID, 
        EMPLOYEE_ID, 
        MANAGER_ID,
        CASE 
            WHEN LEVEL = 1 THEN 0 -- MANAGER X = 트리 최상단
            ELSE 1 -- MANAGER 존재
        END AS HAVE_MANAGER
    FROM EMPLOYEES
    START WITH MANAGER_ID IS NULL
    CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
) S
ON D.DEPARTMENT_ID = S.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_ID
ORDER BY D.DEPARTMENT_ID;


SELECT D.DEPARTMENT_NAME, COUNT(*) - COUNT(E.MANAGER_ID) AS NO_MANAGER,
COUNT(E.MANAGER_ID) AS GOOD_MANAGER
FROM EMPLOYEES E
LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME;
```



