# 정규화
<aside>
💡

데이터 중복 제거 + 데이터 무결성

데이터를 논리적으로 분리 ⇒ 효율적으로 저장하고 관리하도록 함

</aside>

## 1. 제 1정규형

<aside>
💡

모든 속성은 반드시 하나의 값만 가져야 한다.

유사한 속성이 반복되는 경우에도 1차 정규화의 대상

</aside>

## 2. 제 2정규형

<aside>
💡

엔터티의 모든 일반속성은 반드시 모든 주식별자에게 종속되어야 한다

- 일반속성 : 주식별자가 아닌 모든 속성
</aside>

- 삽입 이상 : 새로운 값을 넣으려고 할 때, PK가 null로 되는 등으로 인해 문제가 발생
- 삭제 이상 : 기존의 값을 삭제하려고 할 때 삭제를 원하지 않은 값도 삭제되어 버리는 현상
- 갱신 이상 : 한 값을 모두 수정 ⇒ 다른 값도 모두 수정

- 함수적 종속
    - 예시 : https://mr-dan.tistory.com/10
    
    "이름, 메일, 대학, 전공 모두 학번에 함수적으로 의존하고 있으며, 부분 종속 관계는 없습니다"라는 부분을 좀 더 자세히 설명해드리겠습니다.
    
    ### 1. 함수적 종속 (Functional Dependency)
    
    **함수적 종속**이란 한 속성(컬럼)의 값이 다른 속성(컬럼)의 값을 결정하는 관계를 의미합니다. 예를 들어, "학번 → 이름"이라는 관계는 "학번"만 알면 "이름"을 결정할 수 있다는 뜻입니다.
    
    - **학번 → 이름**: 학번을 알면 그 학생의 이름을 알 수 있습니다.
    - **학번 → 메일**: 학번을 알면 그 학생의 이메일을 알 수 있습니다.
    - **학번 → 대학**: 학번을 알면 그 학생이 속한 대학을 알 수 있습니다.
    - **학번 → 전공**: 학번을 알면 그 학생의 전공을 알 수 있습니다.
    
    이렇게 학번은 다른 속성들의 값을 유일하게 결정할 수 있기 때문에, 모든 속성은 **학번에 함수적으로 의존**한다고 할 수 있습니다.
    
    ### 2. 부분 종속 (Partial Dependency)
    
    **부분 종속**은 복합키(두 개 이상의 속성으로 구성된 기본키)의 일부만으로 다른 속성을 결정하는 관계를 말합니다. 예를 들어, 기본키가 `(학생ID, 과목ID)`라고 할 때, `(학생ID)`만으로 과목과 관계없는 학생의 이름을 알 수 있으면, 이 경우 "학생ID → 이름"은 부분 종속이 됩니다.
    
    하지만 주어진 테이블에서는 **복합키**가 없고, **학번**만이 기본키로 사용된다고 가정할 수 있습니다. 즉, 테이블의 모든 속성(이름, 메일, 대학, 전공)은 **학번**에만 의존하고, 다른 속성에 의존하지 않기 때문에 **부분 종속**은 발생하지 않습니다.
    
    따라서 "이름, 메일, 대학, 전공 모두 학번에 함수적으로 의존하고 있으며, 부분 종속 관계는 없다"는 의미는:
    
    - 모든 속성은 **학번**을 통해 유일하게 결정되며,
    - **복합키**가 아니기 때문에 **부분 종속**이 없다는 것입니다.
    
    ### 3. 예시로 이해하기
    
    - **학번 → 이름**: "학번 12345"라는 학생의 이름은 "김철수"입니다. 학번을 알면 이름을 결정할 수 있습니다.
    - **학번 → 메일**: "학번 12345"의 메일은 "[12345@university.com](mailto:12345@university.com)"입니다. 학번을 알면 메일을 알 수 있습니다.
    - **학번 → 대학**: "학번 12345"의 학생은 "서울대학교"에 다니고 있습니다.
    - **학번 → 전공**: "학번 12345"의 학생은 "컴퓨터공학"을 전공하고 있습니다.
    
    이 모든 정보는 **학번**에 의존하며, 다른 속성들(이름, 메일, 대학, 전공)은 서로 다른 속성에 의존하지 않기 때문에 부분 종속은 없습니다.
    
    ### 결론
    
    따라서, 이 테이블은 **학번 → 이름**, **학번 → 메일**, **학번 → 대학**, **학번 → 전공**과 같은 함수적 종속 관계를 가집니다. 그리고 복합키가 아닌 단일키인 "학번"을 기준으로만 모든 속성이 결정되므로, **부분 종속**은 없습니다.
    

## 3. 제 3정규형

<aside>
💡

주식별자가 아닌 모든 속성 간에는 서로 종속될 수 없다.

</aside>

[학과]

학과번호, 학과명

[학생]

학번, 성명, 학과번호

[교수]

교수번호, 교수명

[LAB실이용신청]

LAB실 이용신청번호, 학번, LAB실 이용신청일, LAB실이용시작일, 이용만기일, 승인교수번호

[대출]

대출번호, 대출자번호, 대출자신분구분(학생, 교수), 대출일자

[대출도서]

대출번호, 도서번호, 반남일자

[도서]

도서번호, 도서명, 출판사명, 출판년월, 대표저자명, ISBN

## 반정규화

- 정규화의 한계
    - 읽기 속도가 중요한 상황에서 정규화된 데이터 모델은 비효율적
- 성능 최적화(데이터 중복 저장하거나 테이블 합치는 방식)
- 주로 OLAP시스템에서 진행

- 반정규화 적용 방법
    - 중복 데이터 저장 : 월별 매출 집계 데이터를 MONTHLY_SALES 테이블로 별도 관리
    - 이력 데이터 관리(PRODUCTS 테이블에 최신 가격과 함께 과거 가격 정보를 중복 저장)
- **반정규화의 장점**
    - 성능
        - 읽기 속도 증가, 조인 연산 감소
        - 대규모 데이터 분석, 보고서 생성 시 유리
    - 간단한 쿼리
        - 데이터 쿼리 단순화
        - 사용자가 테이블 구조 쉽게 이해 가능
    - 특정 요구사항 대응
        - 응용 프로그램에서 특정 데이터 집합을 자주 조회해야 하는 경우
    
- **반정규화의 단점**
    - 데이터 중복
    - 데이터 무결성 문제 ⇒ 삽입, 삭제 문제
    - 유연성 감소

## OLTP

- 실시간 처리
- 정규화된 데이터 구조
- **트랜잭션** 관리(ACID)
    - 트랜잭션 : 데이터베이스 상태를 변환시키기 위한 논리적 작업의 단위
- 데이터베이스 : 관계형 데이터베이스(Oracle, MySQL)
- 사용자 : 실시간으로 데이터를 입력하거나 조회하는 최종 사용자

## OLAP

- 집계, 요약, 패턴 분석 쿼리를 통해 비즈니스 인사이트 제공
- 대규모 데이터 처리 : 데이터 웨어하우스, 데이터마트
- 다차원 데이터 분석 : 시간, 지역, 제품 등 여러 차원을 기준으로 데이터 요약
- 사용자 인터페이스 : 분석 결과 시각적으로 제공하는 대시보드 및 리포트

- ETP 프로세스 : 데이터 웨어하우스로 데이터를 전송하기 위한 프로세스
- OLTP → ETL → OLAP 흐름

- 정규화 : 논리 모델링에서 적용!
- 파티션 : 논리적으로는 동일한 table로 보이나 ⇒ 나눠 놓는 방식

- 데이터베이스에서 하나의 논리적 작업 단위를 의미
- 일련의 작업이 모두 성공 or 실패를 보장
## DDL(Data Definition Language)

- 데이터베이스 객체를 정의하거나 변경
- `CREATE`, `DROP`, `ALTER` , `TRUNCATE`
- ALTER
    - 컬럼명 변경
    
    ```sql
    ALTER TABLE CLIENTS RENAME COLUMN NAME TO FULL_NAME;
    ```
    
    - 테이블명 변경
    
    ```sql
    ALTER TABLE CUSTOMERS RENAME TO CLIENTS;
    ```
    
- DROP
    
    ```sql
    DROP TABLE CUSTOMERS;
    ```
    
- `TRUNCATE`
    
    ```sql
    TRUNCATE TABLE CUSTOMERS;
    ```
    
    - 왜 DELETE보다 TRAUNCATE보다 빠른가?
        - DELETE는 복구를 위한 로그 남김
        - 하지만 TRUNCATE는 로그를 남기지 않음⇒ 그렇지 때문에 더 빠름

## DML(Data Manipulation Language)

- `SELECT`
    
    ```sql
    SELECT NAME, EMAIL
    FROM CUSTOMERS
    WHERE CUSTOMER_ID = 1;
    ```
    
    ```sql
    SELECT * FROM DUAL; // 함수 등 결과자체 값만 궁금할 때, 출력 용도로만 쓸 때
    
    // '가' 글자에서 얼마나 byte 차지하는지 
    SELECT LENGTHB('가') FROM DUAL; 
    ```
    
- `INSERT`
    
    ```sql
    INSERT INTO CUSTOMERS (CUSTOMER_ID, NAME, EMAIL, PHONE)
    VALUES (1, 'JOHN DOE', 'JOHN@EXAMPLE.COM', '555-1234');
    ```
    
- `UPDATE`
    
    ```sql
    UPDATE CUSTOMERS
    SET EMAIL = 'JOHNDOE@EXAMPLE.COM'
    WHERE CUSTOMER_ID = 1;
    ```
    
- `DELETE`
    
    ```sql
    DELETE FROM CUSTOMERS
    WHERE CUSTOMER_ID = 1;
    ```
    

## DCL(Data Control Language)

- `GRANT` , `REVOKE`
- `GRANT` - 권한 부여
    
    ```sql
    GRANT SELECT ON CUSTOMERS TO USER1;
    ```
    
- `REVOKE` - 권한 회수
    
    ```sql
    REVOKE SELECT ON CUSTOMERS TO USER1;
    ```
    

## TCL(Transaction Control Language)

- 트랜잭션 관리 위한 명령어
- `COMMIT`, `ROLLBACK` , `SAVEPOINT`
- `COMMIT`
    - 트랜잭션 확정
- `ROLLBACK`
    - 트랜잭션 취소
- `SAVEPOINT`
    - 특점 지정 저장

---

## 실습

1. DDL

```sql
CREATE TABLE Customer_Grades (
    grade_id VARCHAR2(64) PRIMARY KEY,
    grade_name VARCHAR2(64) NOT NULL,
    creation_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP --  application에서 sysdate에 넣는다
);

-- Customer Info
CREATE TABLE Customer_Info (
    customer_id VARCHAR2(64) PRIMARY KEY,
    grade_id VARCHAR2(64),
    customer_password VARCHAR2(64) NOT NULL,
    customer_name VARCHAR2(64) NOT NULL,
    customer_gender CHAR(1),
    customer_email VARCHAR2(64),
    customer_phone VARCHAR2(64),
    customer_birthdate DATE,
    customer_join_date DATE,
    customer_risk_tolerance CHAR(1),
    creation_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP, --  application에서 sysdate에 넣는다!
    CONSTRAINT fk_customer_info_grade FOREIGN KEY (grade_id) REFERENCES Customer_Grades(grade_id)
);

CREATE TABLE Account_Info (
    account_number VARCHAR2(64) PRIMARY KEY,
    grade_id VARCHAR2(64),
    customer_id VARCHAR2(64),
    status VARCHAR2(4),
    type VARCHAR2(4),
    name VARCHAR2(20),
    password VARCHAR2(64),
    open_date VARCHAR2(8),
    close_date VARCHAR2(8),
    deposit NUMBER,
    withholding NUMBER,
    creation_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP, --  application에서 sysdate에 넣는다!
    CONSTRAINT fk_account_info_grade FOREIGN KEY (grade_id) REFERENCES Customer_Grades(grade_id),
    CONSTRAINT fk_account_info_customer FOREIGN KEY (customer_id) REFERENCES Customer_Info(customer_id)
);

CREATE TABLE Securities_Orders (
    offer_number VARCHAR2(64) PRIMARY KEY,
    account_number VARCHAR2(64),
    customer_id VARCHAR2(64),
    grade_id VARCHAR2(64),
    offer_date DATE,
    product_id VARCHAR2(10),
    status VARCHAR2(4),
    type VARCHAR2(4),
    quantity NUMBER,
    price NUMBER,
    traded NUMBER,
    not_traded NUMBER,
    creation_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP, --  application에서 sysdate에 넣는다
    CONSTRAINT fk_securities_orders_account FOREIGN KEY (account_number) REFERENCES Account_Info(account_number),
    CONSTRAINT fk_securities_orders_customer FOREIGN KEY (customer_id) REFERENCES Customer_Info(customer_id),
    CONSTRAINT fk_securities_orders_grade FOREIGN KEY (grade_id) REFERENCES Customer_Grades(grade_id)
);

CREATE TABLE Stock_Info (
    stock_id VARCHAR2(64) PRIMARY KEY,
    previous_close NUMBER,
    open NUMBER,
    high NUMBER,
    low NUMBER,
    volume NUMBER,
    stock_date DATE,
    dividend NUMBER,
    dividned_date DATE,
    creation_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP --  application에서 sysdate에 넣는다
);

CREATE TABLE Stock_Dividends (
    dividned_id VARCHAR2(64) PRIMARY KEY,
    stock_id VARCHAR2(64),
    account_number VARCHAR2(64),
    customer_id VARCHAR2(64),
    creation_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP, --  application에서 sysdate에 넣는다
    CONSTRAINT fk_stock_dividends_stock FOREIGN KEY (stock_id) REFERENCES Stock_Info(stock_id),
    CONSTRAINT fk_stock_dividends_account FOREIGN KEY (account_number) REFERENCES Account_Info(account_number),
    CONSTRAINT fk_stock_dividends_customer FOREIGN KEY (customer_id) REFERENCES Customer_Info(customer_id)
);

CREATE TABLE Securities_Trades (
    trade_number VARCHAR2(64) PRIMARY KEY,
    trade_date DATE,
    buy_order VARCHAR2(64),
    sell_order VARCHAR2(64),
    quantity NUMBER,
    price NUMBER,
    charge NUMBER(10, 2),
    creation_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP --  application에서 sysdate에 넣는다
);

```

- DML

```sql
-- Customer_Grades 테이블 예시 데이터
INSERT INTO Customer_Grades (grade_id, grade_name)
VALUES ('G1', 'Gold');
INSERT INTO Customer_Grades (grade_id, grade_name)
VALUES ('G2', 'Silver');
INSERT INTO Customer_Grades (grade_id, grade_name)
VALUES ('G3', 'Bronze');

-- Customer_Info 테이블 예시 데이터
INSERT INTO Customer_Info (customer_id, grade_id, customer_password, customer_name, customer_gender, customer_email, customer_phone, customer_birthdate, customer_join_date, customer_risk_tolerance)
VALUES ('C001', 'G1', 'password123', '김지수', 'M', 'kimjisoo@email.com', '010-1234-5678', TO_DATE('1985-04-23', 'YYYY-MM-DD'), TO_DATE('2010-05-01', 'YYYY-MM-DD'), 'H');

INSERT INTO Customer_Info (customer_id, grade_id, customer_password, customer_name, customer_gender, customer_email, customer_phone, customer_birthdate, customer_join_date, customer_risk_tolerance)
VALUES ('C002', 'G2', 'password456', '이영희', 'F', 'leeyounghee@email.com', '010-2345-6789', TO_DATE('1990-07-15', 'YYYY-MM-DD'), TO_DATE('2015-06-01', 'YYYY-MM-DD'), 'M');

-- Account_Info 테이블 예시 데이터
INSERT INTO Account_Info (account_number, grade_id, customer_id, status, type, name, password, open_date, close_date, deposit, withholding)
VALUES ('A001', 'G1', 'C001', 'Actv', 'I', '김지수', 'password123', '20230101', NULL, 5000000, 100000);

INSERT INTO Account_Info (account_number, grade_id, customer_id, status, type, name, password, open_date, close_date, deposit, withholding)
VALUES ('A002', 'G2', 'C002', 'Actv', 'I', '이영희', 'password456', '20230102', NULL, 3000000, 50000);

-- Securities_Orders 테이블 예시 데이터
INSERT INTO Securities_Orders (offer_number, account_number, customer_id, grade_id, offer_date, product_id, status, type, quantity, price, traded, not_traded)
VALUES ('O001', 'A001', 'C001', 'G1', TO_DATE('2023-01-15', 'YYYY-MM-DD'), '005930', 'P', 'Buy', 100, 80000, 50, 50);

INSERT INTO Securities_Orders (offer_number, account_number, customer_id, grade_id, offer_date, product_id, status, type, quantity, price, traded, not_traded)
VALUES ('O002', 'A002', 'C002', 'G2', TO_DATE('2023-01-16', 'YYYY-MM-DD'), '000660', 'C', 'Sell', 50, 120000, 50, 0);

-- Stock_Info 테이블 예시 데이터
INSERT INTO Stock_Info (stock_id, previous_close, open, high, low, volume, stock_date, dividend, dividned_date)
VALUES ('005930', 80000, 81000, 82000, 79000, 1000000, TO_DATE('2023-01-15', 'YYYY-MM-DD'), 1500, TO_DATE('2023-01-14', 'YYYY-MM-DD'));

INSERT INTO Stock_Info (stock_id, previous_close, open, high, low, volume, stock_date, dividend, dividned_date)
VALUES ('000660', 120000, 121000, 122000, 118000, 500000, TO_DATE('2023-01-16', 'YYYY-MM-DD'), 2000, TO_DATE('2023-01-15', 'YYYY-MM-DD'));

-- Stock_Dividends 테이블 예시 데이터
INSERT INTO Stock_Dividends (dividned_id, stock_id, account_number, customer_id, creation_timestamp, update_timestamp)
VALUES ('D001', '005930', 'A001', 'C001', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);

INSERT INTO Stock_Dividends (dividned_id, stock_id, account_number, customer_id, creation_timestamp, update_timestamp)
VALUES ('D002', '000660', 'A002', 'C002', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);

-- Securities_Trades 테이블 예시 데이터
INSERT INTO Securities_Trades (trade_number, trade_date, buy_order, sell_order, quantity, price, charge, creation_timestamp, update_timestamp)
VALUES ('T001', TO_DATE('2023-01-17', 'YYYY-MM-DD'), 'O001', 'O002', 50, 81000, 5000, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);

INSERT INTO Securities_Trades (trade_number, trade_date, buy_order, sell_order, quantity, price, charge, creation_timestamp, update_timestamp)
VALUES ('T002', TO_DATE('2023-01-18', 'YYYY-MM-DD'), 'O002', 'O001', 50, 121000, 10000, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);

```

- 삭제

```sql
-- 외래 키 제약 조건 삭제
ALTER TABLE Stock_Dividends DROP CONSTRAINT fk_stock_dividends_stock;
ALTER TABLE Stock_Dividends DROP CONSTRAINT fk_stock_dividends_account;
ALTER TABLE Stock_Dividends DROP CONSTRAINT fk_stock_dividends_customer;

ALTER TABLE Securities_Orders DROP CONSTRAINT fk_securities_orders_account;
ALTER TABLE Securities_Orders DROP CONSTRAINT fk_securities_orders_customer;
ALTER TABLE Securities_Orders DROP CONSTRAINT fk_securities_orders_grade;

ALTER TABLE Securities_Trades DROP CONSTRAINT fk_securities_trades_buy_order;
ALTER TABLE Securities_Trades DROP CONSTRAINT fk_securities_trades_sell_order;
ALTER TABLE Securities_Trades DROP CONSTRAINT fk_securities_trades_account;
ALTER TABLE Securities_Trades DROP CONSTRAINT fk_securities_trades_customer;

ALTER TABLE Account_Info DROP CONSTRAINT fk_account_info_grade;
ALTER TABLE Account_Info DROP CONSTRAINT fk_account_info_customer;

-- 테이블 삭제
DROP TABLE Stock_Dividends CASCADE CONSTRAINTS;
DROP TABLE Securities_Trades CASCADE CONSTRAINTS;
DROP TABLE Securities_Orders CASCADE CONSTRAINTS;
DROP TABLE Stock_Info CASCADE CONSTRAINTS;
DROP TABLE Account_Info CASCADE CONSTRAINTS;
DROP TABLE Customer_Info CASCADE CONSTRAINTS;
DROP TABLE Customer_Grades CASCADE CONSTRAINTS;

```
# SQL

### 1. SELECT

- 두 SQL구문은 일반적으로 성능이 동일
    - DBMS는 BLOCK단위로 저장하기 때문
    - RDBMS는 한 줄 자체가 ROW단위로 데이터가 저장
    - row 1을 저장하고 BLOCK의 공간이 남으면, row 2가 이어서 저장
    - 따라서 column을 1개를 가져오든 모두 가져오든 모든 block에 모두 접근해야 한다.
    
    ```sql
    SELECT * FROM EMPLOYEES;
    
    SELECT NAME, SALARY FROM EMPLOYEES;
    ```
    
- `ALIAS`
    - SQL의 쿼리에서 컬럼, 테이블에 부여하는 임시 이름
    - 결과 집합의 가독성을 높이고, 복잡한 쿼리를 간결하게 작성할 수 있는 기능
    - 연산 결과에 의미를 부여 ⇒ 가독성 높임
    
    ```sql
    SELECT 컬럼명 AS 별칭
    FROM 테이블명;
    
    -- 예시
    SELECT
        NAME AS EMPLOYEE_NAME,
        SALARY AS MONTHLY_SALARY
    FROM EMPLOYEES;
    
    SELECT SALARY * 12 AS ANNUAL_SALARY
    FROM EMPLOYEES;
    
    -- JOIN
    SELECT
        E.NAME AS EMPLOYEE_NAME,
        D.DEPARTMENT_NAME AS DEPT_NAME
    FROM EMPLOYEES E, DEPARTMENTS D
    WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;
    ```
    

- **Table Alias**

```sql
SELECT E.NAME, E.SALARY
FROM EMPLOYEES E;

-- 다음과 같이 ALIAS를 사용하지 않으면 invalid identifier 문제가 발생
SELECT EMPLOYEES.NAME, E.SALARY
FROM EMPLOYEES E;
```

## 2. NULL

- 의미 : 값이 없음
- Null의 여부는 `IS NULL` 혹은 `IS NOT NULL` 로 해야 함
    - 비교 연산(= , <, > 등)을 수행하면 항상 FALSE 반환

```sql
-- 잘못된 예시 : 다음과 같이 하면 아무 값도 안나옴
SELECT * FROM EMPLOYEES
WHERE NAME = NULL;

SELECT * FROM EMPLOYEES
WHERE NAME IS NULL;
```

- 집계함수를 진행하면 NULL이 아닌 것만 계산함
    - 집계 함수 = COLUMN 연산
    
    ![https://tuna-sssandwich.tistory.com/3](https://prod-files-secure.s3.us-west-2.amazonaws.com/b367ca3a-9b32-4e21-99ce-52536c491502/14be3c67-271c-4a9b-a2c0-bfec489a11b0/image.png)
    
    https://tuna-sssandwich.tistory.com/3
    

## WHERE

- 데이터 필터링
- `SELECT`, `UPDATE`, `DELETE` 와 함께 사용

```sql
SELECT NAME FROM EMPLOYEES WHERE SALARY > 500;
```

## LIKE

`ESCAPE` : 특정 문자 임의로 이스케이프 문자 custom

```sql
SELECT name FROM CUSTOMERS
WHERE name LIKE 'Data\_2024%' ESCAPE '\';
```

## IN

- OR조건으로 대체 가능

```sql
-- DEPARTMENT_ID가 10이고, CUSTOM_ID가 20인 레코드를 조회하는 쿼리

SELECT * FROM EMPLOYEES
WHERE (DEPARTMENT_ID, CUSTOM_ID) IN (10, 20);

-- 여러 튜플 비교
-- DEPARTMENT_ID와 CUSTOM_ID가 각각 (10, 20), (30, 40), (50, 60)인 레코드를 조회

SELECT * FROM EMPLOYEES
WHERE (DEPARTMENT_ID, CUSTOM_ID) IN ((10, 20), (30, 40), (50, 60));
```

## BETWEEN

- 이상 이하

```sql
SELECT * FROM EMPLOYEE
WHERE SALARY BETWEEN 30000 AND 50000;

SELECT * FROM EMPLOYEE
WHERE SALARY >= 30000 AND SALARY <= 50000;

```

## 연산자 우선순위

1. 괄호
2. 비교 연산자(<, >, = 등)
3. 논리 연산자
    
    3.1 NOT
    
    3.2 AND
    
    3.3 OR

# Transaction
## Atomicity(원자성)

- 트랜잭션은 모두 실행되거나 실행되지 않아야 함

## Consistency(일관성)

- 트랜잭션이 성공적으로 완료되었을 때, 데이터 무결성 맞아야 한다.

## Isolation(고립성)

- 하나의 트랜잭션 진행 시, 다른 트랜잭션은 해당 트랜잭션이 끝날 때까지 간섭하지 않도록 해야 한다.
- 트랜잭션 격리 수준으로 구현
- read-uncommited
- repeatable-read
- serializable

<aside>
💡

**FOR ~ UPDATE**

- https://dololak.tistory.com/446
</aside>

## Durability(지속성)

- 트랜잭션 이후에는 데이터베이스에 해당 작업이 영구적으로 반영되어야 한다.
- 시스템 장애 후에도 데이터는 유지
